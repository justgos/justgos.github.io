{"version":3,"sources":["config.js","core/state.js","util/time.js","data/ProjectData.js","components/SceneController.js","util/HTMLRenderer.js","compute/GPUComputationRenderer.js","shaders/PixelSwarmShader.js","shaders/SimplexNoise.js","shaders/PixelSwarmComputeShaders.js","components/PixelSwarm.js","util/array.js","components/SwarmTarget.js","components/ProjectInfo.js","shaders/DynamicCanvasShader.js","components/DynamicCanvas.js","App.js","serviceWorker.js","index.js"],"names":["dpi","window","devicePixelRatio","allReducers","combineReducers","swarmTargets","state","action","type","payload","target","data","swarmState","store","createStore","sleep","ms","Promise","resolve","setTimeout","ProjectData","inProgress","id","name","desc","links","previewType","previewSize","archive","tech","label","url","video","href","rel","previewScale","image","SceneController","children","useThree","size","width","height","camera","useMemo","value","performance","now","fpsCount","lastTime","lastReportTime","sceneRef","useRef","mainLight","useFrame","curTime","position","x","y","current","Math","round","ref","intensity","rotation","THREE","castShadow","HTMLRenderer","dummyCanvas","document","createElement","reject","img","Image","onload","onerror","src","AwaitImageLoad","canvas","className","body","appendChild","ctx","getContext","scale","clearRect","drawImage","pixels","getImageData","removeChild","GPUComputationRenderer","sizeX","sizeY","renderer","this","variables","currentTextureIndex","scene","z","passThruUniforms","passThruTexture","passThruShader","createShaderMaterial","mesh","addResolutionDefine","materialShader","defines","resolution","toFixed","computeFragmentShader","uniforms","material","vertexShader","fragmentShader","add","addVariable","variableName","initialValueTexture","variable","dependencies","renderTargets","wrapS","wrapT","minFilter","magFilter","push","setVariableDependencies","init","extensions","get","capabilities","isWebGL2","maxVertexTextures","i","length","createRenderTarget","renderTexture","d","depVar","found","j","compute","nextTextureIndex","il","dl","texture","doRenderTarget","getCurrentRenderTarget","getAlternateRenderTarget","sizeXTexture","sizeYTexture","format","stencilBuffer","depthBuffer","createTexture","Float32Array","input","output","currentRenderTarget","getRenderTarget","setRenderTarget","render","PixelSwarmShader","options","blending","depthTest","transparent","vertexColors","time","targetType","positionTex","colorTex","pointTexture","pointScale","posOffset","SimplexNoise3D","PixelSwarmTargetPositionShader","PixelSwarmVelocityShader","PixelSwarm","n","computeTexSize","gl","useState","setTarget","getState","targets","setTargets","subscribe","positions","arr","random","references","floor","fillPositionTex","tex","texData","fillZeroTex","gpuCompute","targetPositionTex","velocityTex","targetColorTex","targetPositionVariable","velocityVariable","positionVariable","colorVariable","error","console","dispatch","updateSwarmState","useEffect","needsUpdate","colors","loader","load","swarmShader","lastTargetOffset","intendedTarget","dtime","min","scrollTop","scrollingElement","viewport","max","documentElement","clientWidth","innerWidth","clientHeight","innerHeight","maxPriority","targetIds","Object","keys","el","getElementById","offsetTop","offsetHeight","priority","targetEl","targetSize","offsetWidth","targetOffset","offsetLeft","dTargetOffset","velocityNoiseScale","points","frustumCulled","attach","attachObject","count","array","itemSize","args","shuffle","a","stride","repeatIndices","repeatStride","ii","indices","k","connect","ownProps","targetData","updateSwarmTarget","removeSwarmTarget","newTargetData","renderImage","pix","shuffleIndices","renderContent","style","ProjectInfo","project","key","map","link","alt","autoPlay","playsInline","loop","muted","DynamicCanvasShader","blendSrc","blendDst","DynamicCanvas","rttScene","rttGroup","rttBg","realScene","realBg","targetOptions","RGBAFormat","UnsignedByteType","generateMipmaps","WebGLRenderTarget","OrthographicCamera","left","right","top","bottom","near","far","rttCamera","setClearColor","Color","clear","opacity","App","locked","setLocked","logoShape","setLogoShape","logoPointSize","setLogoPointSize","revealStage","setRevealStage","location","hash","reveal","shouldRender","setShouldRender","onScroll","e","log","addEventListener","removeEventListener","fov","orthographic","pixelRatio","invalidateFrameloop","Boolean","hostname","match","ReactDOM","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.753edeee.chunk.js","sourcesContent":["export const dpi = window.devicePixelRatio || 1;\r\n","import { combineReducers, createStore } from 'redux';\r\n\r\nexport const updateSwarmTarget = (target, data) => {\r\n    return {\r\n        type: 'UPDATE_TARGET',\r\n        payload: {\r\n            target,\r\n            data\r\n        }\r\n    }\r\n};\r\n\r\nexport const removeSwarmTarget = (target) => {\r\n    return {\r\n        type: 'REMOVE_TARGET',\r\n        payload: {\r\n            target\r\n        }\r\n    }\r\n};\r\n\r\nexport const swarmTargets = (state = {}, action) => {\r\n    switch(action.type) {\r\n        case 'UPDATE_TARGET':\r\n            state[action.payload.target] = action.payload.data;\r\n            return state;\r\n        case 'REMOVE_TARGET':\r\n            delete state[action.payload.target];\r\n            return state;\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\n\r\nexport const updateSwarmState = ({ positionTex }) => {\r\n    return {\r\n        type: 'UPDATE_STATE',\r\n        payload: {\r\n            positionTex\r\n        }\r\n    }\r\n};\r\n\r\nexport const swarmState = (state = {}, action) => {\r\n    switch(action.type) {\r\n        case 'UPDATE_STATE':\r\n            state = {\r\n                ...state,\r\n                ...action.payload\r\n            };\r\n            return state;\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\nexport const allReducers = combineReducers({\r\n    swarmTargets,\r\n    swarmState,\r\n});\r\n\r\nexport const store = createStore(\r\n    allReducers\r\n);\r\n","export function sleep(ms) {\r\n  return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\n","import React from 'react'\r\n\r\nexport const ProjectData = {\r\n  inProgress: [\r\n    {\r\n      id: \"currently\",\r\n      name: \"[unnamed project]\",\r\n      desc: (\r\n        <div>\r\n          Pondering how to link biological observations across spatial and temporal scales.<br/>\r\n          To draw long-range inferences that'd fill gaps in our knowledge\r\n        </div>\r\n      ),\r\n      // tech: [\"Python\"],\r\n      links: [\r\n        //{ label: \"view graph\", url: \"https://graph.gos.garden/#z=1530.00/47.98/0.51\" },\r\n      ],\r\n      // image: \"/textures/project-thingness-image.png\",\r\n      //video: \"/video/currently.mp4\",\r\n      previewType: \"generative-thomas\",\r\n      previewSize: [ 400, 400 ],\r\n    },\r\n    // {\r\n    //   id: \"excog-2\",\r\n    //   name: \"Extended Knowledge v2\",\r\n    //   desc: (\r\n    //     <div>\r\n    //       A personal tool for thinking\r\n    //     </div>\r\n    //   ),\r\n    //   // tech: [\"Python\"],\r\n    //   links: [\r\n    //     { label: \"view graph\", url: \"https://graph.gos.garden/#z=1530.00/47.98/0.51\" },\r\n    //   ],\r\n    //   // image: \"/textures/project-thingness-image.png\",\r\n    //   video: \"/video/excog-2.mp4\",\r\n    //   previewType: \"generative-thomas\",\r\n    //   previewSize: [ 400, 400 ],\r\n    // },\r\n  ],\r\n  archive: [\r\n    {\r\n      id: \"spatial-cell\",\r\n      name: \"Spatial cell\",\r\n      desc: (\r\n        <div>\r\n          Molecule-scale simulation of a biological cell\r\n        </div>\r\n      ),\r\n      tech: [\"C++\", \"CUDA\", \"Unity\", \"Python\"],\r\n      links: [\r\n        { label: \"blog post\", url: \"https://graph.gos.garden/node/4bbb96b6-d858-419a-94d3-e7eae9e008ad#\" },\r\n        { label: \"github\", url: \"https://github.com/justgos/spatial-cell\" },\r\n      ],\r\n      // image: \"/textures/project-thingness-image.png\",\r\n      video: \"/video/spatial-cell.mp4\",\r\n      previewType: \"generative-thomas\",\r\n      previewSize: [ 400, 400 ],\r\n    },\r\n    {\r\n      id: \"indagatio-muris-senis\",\r\n      name: \"Indagatio Muris Senis\",\r\n      desc: (\r\n        <div>\r\n          Exploration of the Mus Musculus aging dynamics\r\n        </div>\r\n      ),\r\n      tech: [\"Python\", \"TypeScript\", \"WebGL\"],\r\n      links: [\r\n        { label: \"visualization\", url: \"https://gos.garden/vis-age/\" },\r\n        { label: \"github\", url: \"https://github.com/justgos/indagatio-muris-senis\" },\r\n      ],\r\n      // image: \"/textures/project-thingness-image.png\",\r\n      video: \"/video/indagatio-muris-senis.mp4\",\r\n      previewType: \"generative-thomas\",\r\n      previewSize: [ 400, 400 ],\r\n    },\r\n    {\r\n      id: \"thingness\",\r\n      name: \"Thingness\",\r\n      desc: (\r\n        <div>\r\n          Exploration of cell-level morphogenesis in 2D\r\n        </div>\r\n      ),\r\n      tech: [\"Python\"],\r\n      links: [\r\n        { label: \"github\", url: \"https://github.com/justgos/thingness\" },\r\n      ],\r\n      // image: \"/textures/project-thingness-image.png\",\r\n      video: \"/video/thingness.mp4\",\r\n      previewType: \"generative-thomas\",\r\n      previewSize: [ 400, 400 ],\r\n    },\r\n    {\r\n      id: \"excog\",\r\n      name: \"Extended Knowledge v1\",\r\n      desc: (\r\n        <div>\r\n          A tool for thinking on scales larger/longer than mindmaps usually allow for.<br/>\r\n          Augmented with <a href=\"https://en.wikipedia.org/wiki/Extended_cognition\" target=\"_blank\" rel=\"noopener noreferrer\">Wikipedia</a> data\r\n        </div>\r\n      ),\r\n      tech: [\"React\", \"Canvas rendering\", \"socket.io\", \"Node.js\", \"Mongo\", \"Neo4j\", \"ElasticSearch\"],\r\n      links: [\r\n        // { label: \"website\", url: \"https://extendedcognition.org/\" },\r\n        { label: \"iteration 1 (video)\", url: \"https://www.youtube.com/watch?v=pQgasxd2-mE\" },\r\n        { label: \"iteration 2 (video)\", url: \"https://www.youtube.com/watch?v=aPhjCrcgRPY\" },\r\n        { label: \"iteration 3 (video)\", url: \"https://www.youtube.com/watch?v=FmLUpeSrsC0\" },\r\n      ],\r\n      // image: \"/textures/project-excog-image.png\",\r\n      video: \"/video/ex-k.mp4\",\r\n      previewType: \"generative-excog\",\r\n      previewSize: [ 400, 400 ],\r\n    },\r\n    {\r\n      id: \"eso\",\r\n      name: \"EcoSystemOne\",\r\n      desc: (\r\n        <div>\r\n          A platform where you learn by teaching others â€” by telling stories together, in&nbsp;VR\r\n        </div>\r\n      ),\r\n      tech: [\"Unity (Photon, SteamVR)\", \"Node.js\", \"Mongo\", \"ElasticSearch\", \"Python\", \"AWS\", \"Docker Swarm\"],\r\n      links: [\r\n        { label: \"website\", url: \"https://ecosystemone.com/\" },\r\n      ],\r\n      // image: \"/textures/project-eso-image.png\",\r\n      video: \"/video/act.mp4\",\r\n      previewType: \"content\",\r\n      previewSize: [ 400, 400 ],\r\n      previewScale: 7,\r\n    },\r\n    {\r\n      id: \"body-evo\",\r\n      name: \"Mind-body evolution\",\r\n      desc: (\r\n        <div>\r\n          Agents can evolve new limbs, which add new sensory and motor neurons.<br/>\r\n          Mind is a Spiking Neural Network, implemented in <a href=\"https://brian2.readthedocs.io/en/stable/\" target=\"_blank\" rel=\"noopener noreferrer\">brian2</a> and using <a href=\"http://www.izhikevich.org/publications/spikes.htm\" target=\"_blank\" rel=\"noopener noreferrer\">Izhikevich</a> cells dynamics.\r\n        </div>\r\n      ),\r\n      tech: [\"Python (Brian2)\", \"Unity\", \"ZeroMQ\"],\r\n      // links: [\r\n      //   { label: \"website\", url: \"https://ecosystemone.com/\" },\r\n      // ],\r\n      image: \"/textures/body-evo-mind-structure.jpg\",\r\n      previewType: \"generative-van-der-pol\",\r\n      previewSize: [ 400, 400 ],\r\n    },\r\n    {\r\n      id: \"brave-gen\",\r\n      name: \"Artificial worlds\",\r\n      desc: (\r\n        <div>\r\n          Terrain generation and object placement are inspired by <a href=\"https://www.youtube.com/watch?v=SePDzis8HqY\" target=\"_blank\" rel=\"noopener noreferrer\">No Man's Sky</a>.<br/>\r\n          Air dynamics are a voxel-based simulation, based on <a href=\"http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch38.html\" target=\"_blank\" rel=\"noopener noreferrer\">GPU Gems</a> article.\r\n          {/* <p>\r\n            Originally meant to be a dynamic environment for artificial agents to adapt to, but it hasn't got to that point\r\n          </p> */}\r\n        </div>\r\n      ),\r\n      tech: [\"Unity\", \"Python\"],\r\n      links: [\r\n        { label: \"github\", url: \"https://github.com/justgos/brave-gen\" },\r\n      ],\r\n      // image: \"/textures/project--image.png\",\r\n      video: \"/video/brave-gen.mp4\",\r\n      previewType: \"generative-van-der-pol\",\r\n      previewSize: [ 400, 400 ],\r\n    },\r\n    {\r\n      id: \"l2mapper\",\r\n      name: \"Map viewer for Lineage II\",\r\n      desc: (\r\n        <div>\r\n          In a time of being somewhat obsessed with the game, spent a few weeks dawn till dusk trying to find ways to read an altered Unreal Engine data format and understanding how it's meant to be visualized.\r\n        </div>\r\n      ),\r\n      tech: [\"C++\", \"OpenGL\"],\r\n      links: [\r\n        { label: \"github\", url: \"https://github.com/justgos/l2mapper\" },\r\n      ],\r\n      image: \"/textures/l2mapper.jpg\",\r\n      previewType: \"content\",\r\n      previewSize: [ 500, 379 ],\r\n      previewScale: 8,\r\n    },\r\n  ],\r\n}\r\n      ","import * as THREE from 'three'\r\nimport React, { useMemo, useRef } from 'react'\r\nimport { useFrame, useThree } from 'react-three-fiber'\r\n\r\nimport { dpi } from '../config'\r\n\r\nexport default function SceneController({ children }) {\r\n  const {\r\n    size: { width, height },\r\n    camera,\r\n  } = useThree();\r\n\r\n  const [ fpsCount, lastTime, lastReportTime]  = useMemo(\r\n    () => {\r\n      return [ { value: 0 }, { value: performance.now() }, { value: performance.now() } ]\r\n    }, []\r\n  );\r\n  const sceneRef = useRef();\r\n  const mainLight = useRef();\r\n  useFrame(() => {\r\n    let curTime = performance.now();\r\n    lastTime.value = curTime;\r\n    fpsCount.value++;\r\n    if(curTime > lastReportTime.value + 1000.0) {\r\n        // console.log('fps', fpsCount.value);\r\n        lastReportTime.value = curTime;\r\n        fpsCount.value = 0;\r\n    }\r\n\r\n    let scrollTop = 0;  // document.scrollingElement.scrollTop;\r\n\r\n    camera.position.x = width / 2;\r\n    camera.position.y = -height / 2;\r\n\r\n    // mainLight.current.position.x = width / 2 + 200;\r\n    // mainLight.current.position.y = -height / 2 + 100;\r\n    mainLight.current.position.y = -scrollTop;\r\n\r\n    sceneRef.current.position.y = Math.round(scrollTop * dpi) / dpi\r\n  });\r\n\r\n  return (\r\n      <scene ref={sceneRef}>\r\n        <ambientLight intensity={0.5} />\r\n        <directionalLight intensity={0.6} position={[0, 0, 1000]} rotation={new THREE.Euler(0, 0, 0)} castShadow ref={mainLight} />\r\n        {/* <spotLight intensity={0.7} position={[0, 0, 1000]} rotation={new THREE.Euler(0, 0, 0)} angle={Math.PI / 2} penumbra={1} castShadow ref={mainLight} /> */}\r\n        {children}\r\n      </scene>\r\n  );\r\n}\r\n","import ReactDOM from 'react-dom'\r\n\r\nimport { dpi } from '../config'\r\n\r\nexport default class HTMLRenderer {\r\n  static dummyCanvas;\r\n  static offscreenCanvas;\r\n\r\n  static getDummyCanvas() {\r\n    if(!HTMLRenderer.dummyCanvas) {\r\n      HTMLRenderer.dummyCanvas = document.createElement('canvas');\r\n      HTMLRenderer.dummyCanvas.width = HTMLRenderer.dummyCanvas.height = 1;\r\n    }\r\n    return HTMLRenderer.dummyCanvas;\r\n  }\r\n\r\n  static AwaitImageLoad(url, size) {\r\n    return new Promise((resolve, reject) => {\r\n      let img = new Image()\r\n      // img.width = size[0];\r\n      // img.height = size[1];\r\n      img.onload = () => resolve(img)\r\n      img.onerror = reject\r\n      img.src = url\r\n    });\r\n  }\r\n\r\n  static async renderImage(url, size) {\r\n    let img = await HTMLRenderer.AwaitImageLoad(url, size);\r\n    let canvas = document.createElement('canvas');\r\n    canvas.className = \"html-render-container\";\r\n    document.body.appendChild(canvas); \r\n    canvas.width = size[0] * dpi;\r\n    canvas.height = size[1] * dpi;\r\n    let ctx = canvas.getContext(\"2d\");\r\n    ctx.scale(dpi, dpi);\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    // ctx.beginPath();\r\n    // ctx.moveTo(0, 0);\r\n    // ctx.lineTo(150, 150);\r\n    // ctx.stroke();\r\n    ctx.drawImage(img, 0, 0, size[0], size[1]);\r\n    let pixels = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\r\n\r\n    document.body.removeChild(canvas);\r\n    return pixels;\r\n  }\r\n}\r\n","/**\n * @author yomboprime https://github.com/yomboprime\n *\n * GPUComputationRenderer, based on SimulationRenderer by zz85\n *\n * The GPUComputationRenderer uses the concept of variables. These variables are RGBA float textures that hold 4 floats\n * for each compute element (texel)\n *\n * Each variable has a fragment shader that defines the computation made to obtain the variable in question.\n * You can use as many variables you need, and make dependencies so you can use textures of other variables in the shader\n * (the sampler uniforms are added automatically) Most of the variables will need themselves as dependency.\n *\n * The renderer has actually two render targets per variable, to make ping-pong. Textures from the current frame are used\n * as inputs to render the textures of the next frame.\n *\n * The render targets of the variables can be used as input textures for your visualization shaders.\n *\n * Variable names should be valid identifiers and should not collide with THREE GLSL used identifiers.\n * a common approach could be to use 'texture' prefixing the variable name; i.e texturePosition, textureVelocity...\n *\n * The size of the computation (sizeX * sizeY) is defined as 'resolution' automatically in the shader. For example:\n * #DEFINE resolution vec2( 1024.0, 1024.0 )\n *\n * -------------\n *\n * Basic use:\n *\n * // Initialization...\n *\n * // Create computation renderer\n * var gpuCompute = new THREE.GPUComputationRenderer( 1024, 1024, renderer );\n *\n * // Create initial state float textures\n * var pos0 = gpuCompute.createTexture();\n * var vel0 = gpuCompute.createTexture();\n * // and fill in here the texture data...\n *\n * // Add texture variables\n * var velVar = gpuCompute.addVariable( \"textureVelocity\", fragmentShaderVel, pos0 );\n * var posVar = gpuCompute.addVariable( \"texturePosition\", fragmentShaderPos, vel0 );\n *\n * // Add variable dependencies\n * gpuCompute.setVariableDependencies( velVar, [ velVar, posVar ] );\n * gpuCompute.setVariableDependencies( posVar, [ velVar, posVar ] );\n *\n * // Add custom uniforms\n * velVar.material.uniforms.time = { value: 0.0 };\n *\n * // Check for completeness\n * var error = gpuCompute.init();\n * if ( error !== null ) {\n *\t\tconsole.error( error );\n  * }\n *\n *\n * // In each frame...\n *\n * // Compute!\n * gpuCompute.compute();\n *\n * // Update texture uniforms in your visualization materials with the gpu renderer output\n * myMaterial.uniforms.myTexture.value = gpuCompute.getCurrentRenderTarget( posVar ).texture;\n *\n * // Do your rendering\n * renderer.render( myScene, myCamera );\n *\n * -------------\n *\n * Also, you can use utility functions to create ShaderMaterial and perform computations (rendering between textures)\n * Note that the shaders can have multiple input textures.\n *\n * var myFilter1 = gpuCompute.createShaderMaterial( myFilterFragmentShader1, { theTexture: { value: null } } );\n * var myFilter2 = gpuCompute.createShaderMaterial( myFilterFragmentShader2, { theTexture: { value: null } } );\n *\n * var inputTexture = gpuCompute.createTexture();\n *\n * // Fill in here inputTexture...\n *\n * myFilter1.uniforms.theTexture.value = inputTexture;\n *\n * var myRenderTarget = gpuCompute.createRenderTarget();\n * myFilter2.uniforms.theTexture.value = myRenderTarget.texture;\n *\n * var outputRenderTarget = gpuCompute.createRenderTarget();\n *\n * // Now use the output texture where you want:\n * myMaterial.uniforms.map.value = outputRenderTarget.texture;\n *\n * // And compute each frame, before rendering to screen:\n * gpuCompute.doRenderTarget( myFilter1, myRenderTarget );\n * gpuCompute.doRenderTarget( myFilter2, outputRenderTarget );\n *\n *\n *\n * @param {int} sizeX Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {int} sizeY Computation problem size is always 2d: sizeX * sizeY elements.\n * @param {WebGLRenderer} renderer The renderer\n  */\n\nimport * as THREE from 'three'\n\nconst GPUComputationRenderer = function ( sizeX, sizeY, renderer ) {\n\n\tthis.variables = [];\n\n\tthis.currentTextureIndex = 0;\n\n\tvar scene = new THREE.Scene();\n\n\tvar camera = new THREE.Camera();\n\tcamera.position.z = 1;\n\n\tvar passThruUniforms = {\n\t\tpassThruTexture: { value: null }\n\t};\n\n\tvar passThruShader = createShaderMaterial( getPassThroughFragmentShader(), passThruUniforms );\n\n\tvar mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), passThruShader );\n\tscene.add( mesh );\n\n\n\tthis.addVariable = function ( variableName, computeFragmentShader, initialValueTexture ) {\n\n\t\tvar material = this.createShaderMaterial( computeFragmentShader );\n\n\t\tvar variable = {\n\t\t\tname: variableName,\n\t\t\tinitialValueTexture: initialValueTexture,\n\t\t\tmaterial: material,\n\t\t\tdependencies: null,\n\t\t\trenderTargets: [],\n\t\t\twrapS: null,\n\t\t\twrapT: null,\n\t\t\tminFilter: THREE.NearestFilter,\n\t\t\tmagFilter: THREE.NearestFilter\n\t\t};\n\n\t\tthis.variables.push( variable );\n\n\t\treturn variable;\n\n\t};\n\n\tthis.setVariableDependencies = function ( variable, dependencies ) {\n\n\t\tvariable.dependencies = dependencies;\n\n\t};\n\n\tthis.init = function () {\n\n\t\tif ( ! renderer.extensions.get( \"OES_texture_float\" ) &&\n\t\t\t ! renderer.capabilities.isWebGL2 ) {\n\n\t\t\treturn \"No OES_texture_float support for float textures.\";\n\n\t\t}\n\n\t\tif ( renderer.capabilities.maxVertexTextures === 0 ) {\n\n\t\t\treturn \"No support for vertex shader textures.\";\n\n\t\t}\n\n\t\tfor ( var i = 0; i < this.variables.length; i ++ ) {\n\n\t\t\tvar variable = this.variables[ i ];\n\n\t\t\t// Creates rendertargets and initialize them with input texture\n\t\t\tvariable.renderTargets[ 0 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\tvariable.renderTargets[ 1 ] = this.createRenderTarget( sizeX, sizeY, variable.wrapS, variable.wrapT, variable.minFilter, variable.magFilter );\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 0 ] );\n\t\t\tthis.renderTexture( variable.initialValueTexture, variable.renderTargets[ 1 ] );\n\n\t\t\t// Adds dependencies uniforms to the ShaderMaterial\n\t\t\tvar material = variable.material;\n\t\t\tvar uniforms = material.uniforms;\n\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\tfor ( var d = 0; d < variable.dependencies.length; d ++ ) {\n\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\n\n\t\t\t\t\tif ( depVar.name !== variable.name ) {\n\n\t\t\t\t\t\t// Checks if variable exists\n\t\t\t\t\t\tvar found = false;\n\t\t\t\t\t\tfor ( var j = 0; j < this.variables.length; j ++ ) {\n\n\t\t\t\t\t\t\tif ( depVar.name === this.variables[ j ].name ) {\n\n\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( ! found ) {\n\n\t\t\t\t\t\t\treturn \"Variable dependency not found. Variable=\" + variable.name + \", dependency=\" + depVar.name;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tuniforms[ depVar.name ] = { value: null };\n\n\t\t\t\t\tmaterial.fragmentShader = \"\\nuniform sampler2D \" + depVar.name + \";\\n\" + material.fragmentShader;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.currentTextureIndex = 0;\n\n\t\treturn null;\n\n\t};\n\n\tthis.compute = function () {\n\n\t\tvar currentTextureIndex = this.currentTextureIndex;\n\t\tvar nextTextureIndex = this.currentTextureIndex === 0 ? 1 : 0;\n\n\t\tfor ( var i = 0, il = this.variables.length; i < il; i ++ ) {\n\n\t\t\tvar variable = this.variables[ i ];\n\n\t\t\t// Sets texture dependencies uniforms\n\t\t\tif ( variable.dependencies !== null ) {\n\n\t\t\t\tvar uniforms = variable.material.uniforms;\n\t\t\t\tfor ( var d = 0, dl = variable.dependencies.length; d < dl; d ++ ) {\n\n\t\t\t\t\tvar depVar = variable.dependencies[ d ];\n\n\t\t\t\t\tuniforms[ depVar.name ].value = depVar.renderTargets[ currentTextureIndex ].texture;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Performs the computation for this variable\n\t\t\tthis.doRenderTarget( variable.material, variable.renderTargets[ nextTextureIndex ] );\n\n\t\t}\n\n\t\tthis.currentTextureIndex = nextTextureIndex;\n\n\t};\n\n\tthis.getCurrentRenderTarget = function ( variable ) {\n\n\t\treturn variable.renderTargets[ this.currentTextureIndex ];\n\n\t};\n\n\tthis.getAlternateRenderTarget = function ( variable ) {\n\n\t\treturn variable.renderTargets[ this.currentTextureIndex === 0 ? 1 : 0 ];\n\n\t};\n\n\tfunction addResolutionDefine( materialShader ) {\n\n\t\tmaterialShader.defines.resolution = 'vec2( ' + sizeX.toFixed( 1 ) + ', ' + sizeY.toFixed( 1 ) + \" )\";\n\n\t}\n\tthis.addResolutionDefine = addResolutionDefine;\n\n\n\t// The following functions can be used to compute things manually\n\n\tfunction createShaderMaterial( computeFragmentShader, uniforms ) {\n\n\t\tuniforms = uniforms || {};\n\n\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\tuniforms: uniforms,\n\t\t\tvertexShader: getPassThroughVertexShader(),\n\t\t\tfragmentShader: computeFragmentShader\n\t\t} );\n\n\t\taddResolutionDefine( material );\n\n\t\treturn material;\n\n\t}\n\n\tthis.createShaderMaterial = createShaderMaterial;\n\n\tthis.createRenderTarget = function ( sizeXTexture, sizeYTexture, wrapS, wrapT, minFilter, magFilter ) {\n\n\t\tsizeXTexture = sizeXTexture || sizeX;\n\t\tsizeYTexture = sizeYTexture || sizeY;\n\n\t\twrapS = wrapS || THREE.ClampToEdgeWrapping;\n\t\twrapT = wrapT || THREE.ClampToEdgeWrapping;\n\n\t\tminFilter = minFilter || THREE.NearestFilter;\n\t\tmagFilter = magFilter || THREE.NearestFilter;\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget( sizeXTexture, sizeYTexture, {\n\t\t\twrapS: wrapS,\n\t\t\twrapT: wrapT,\n\t\t\tminFilter: minFilter,\n\t\t\tmagFilter: magFilter,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\t// type: ( /(iPad|iPhone|iPod)/g.test( navigator.userAgent ) ) ? THREE.HalfFloatType : THREE.FloatType,\n\t\t\ttype: THREE.FloatType,\n\t\t\tstencilBuffer: false,\n\t\t\tdepthBuffer: false\n\t\t} );\n\n\t\treturn renderTarget;\n\n\t};\n\n\tthis.createTexture = function () {\n\n\t\tvar data = new Float32Array( sizeX * sizeY * 4 );\n\t\treturn new THREE.DataTexture( data, sizeX, sizeY, THREE.RGBAFormat, THREE.FloatType );\n\n\t};\n\n\tthis.renderTexture = function ( input, output ) {\n\n\t\t// Takes a texture, and render out in rendertarget\n\t\t// input = Texture\n\t\t// output = RenderTarget\n\n\t\tpassThruUniforms.passThruTexture.value = input;\n\n\t\tthis.doRenderTarget( passThruShader, output );\n\n\t\tpassThruUniforms.passThruTexture.value = null;\n\n\t};\n\n\tthis.doRenderTarget = function ( material, output ) {\n\n\t\tvar currentRenderTarget = renderer.getRenderTarget();\n\n\t\tmesh.material = material;\n\t\trenderer.setRenderTarget( output );\n\t\trenderer.render( scene, camera );\n\t\tmesh.material = passThruShader;\n\n\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t};\n\n\t// Shaders\n\n\tfunction getPassThroughVertexShader() {\n\n\t\treturn\t\"void main()\t{\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tgl_Position = vec4( position, 1.0 );\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"}\\n\";\n\n\t}\n\n\tfunction getPassThroughFragmentShader() {\n\n\t\treturn\t\"uniform sampler2D passThruTexture;\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"void main() {\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tvec2 uv = gl_FragCoord.xy / resolution.xy;\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"\tgl_FragColor = texture2D( passThruTexture, uv );\\n\" +\n\t\t\t\t\"\\n\" +\n\t\t\t\t\"}\\n\";\n\n\t}\n\n};\n\nexport default GPUComputationRenderer;\n","import * as THREE from 'three'\r\n\r\nexport default class PixelSwarmShader extends THREE.ShaderMaterial {\r\n  constructor(options) {\r\n    super({\r\n      vertexShader: `\r\n        attribute vec2 reference;\r\n        varying vec4 vColor;\r\n        uniform float time;\r\n        uniform sampler2D positionTex;\r\n        uniform sampler2D colorTex;\r\n        uniform float pointScale;\r\n        uniform vec2 posOffset;\r\n        uniform int targetType;\r\n\r\n        vec2 unpack2HalfToRGBA(vec4 v) {\r\n          return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\r\n        }\r\n\r\n        void main() {\r\n            // vColor.xyz = color;\r\n            // vColor.w = alpha;\r\n            vColor = texture2D(colorTex, reference);\r\n            // vColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n\r\n            if(targetType == 2) {\r\n              vColor.w = pow(abs(sin(time * 0.5 + reference.x * 10.0)), 2.0);\r\n            }\r\n\r\n            vec4 pos = texture2D(positionTex, reference);\r\n            pos.xy += posOffset;\r\n            pos.z = 0.0;\r\n            // vec2 pos1 = unpack2HalfToRGBA(texture2D(positionTex, reference.xy));\r\n            // vec2 pos2 = unpack2HalfToRGBA(texture2D(positionTex, reference.zw));\r\n            // vec4 pos = vec4(pos1.x, pos1.y, pos2.x, 1.0);\r\n            vec4 mvPosition = modelViewMatrix * vec4( pos.xyz, 1.0 );\r\n            gl_PointSize = pointScale;  //  * abs(texture2D(posTexture, vec2(position.x / 1000.0, 0.0)).x)\r\n            gl_Position = projectionMatrix * mvPosition;\r\n        }\r\n      `,\r\n      fragmentShader: `\r\n        uniform sampler2D pointTexture;\r\n        varying vec4 vColor;\r\n        void main() {\r\n          // gl_FragColor = vec4( vColor, 1.0 );\r\n          gl_FragColor = vColor;\r\n          // gl_FragColor = vec4(1.0, 1.0, 1.0, vColor.w) * texture2D(pointTexture, gl_PointCoord);\r\n          gl_FragColor.w *= 0.3;\r\n        }\r\n      `,\r\n      // blendSrc: THREE.OneFactor,\r\n      // blendDst: THREE.OneFactor,\r\n      // blending: THREE.CustomBlending,\r\n      // blendEquation: THREE.AddEquation,\r\n      blending: THREE.AdditiveBlending,\r\n      // blending: THREE.SubtractiveBlending,\r\n      // blending: THREE.NormalBlending,\r\n      depthTest: false,\r\n      transparent: true,\r\n      vertexColors: true,\r\n    });\r\n\r\n    this.uniforms = {\r\n      time: { value: options.time },\r\n      targetType: { value: options.targetType },\r\n      positionTex: { value: options.positionTex },\r\n      colorTex: { value: options.colorTex },\r\n      pointTexture: { value: options.pointTexture },\r\n      pointScale: { value: options.pointScale },\r\n      posOffset: { value: options.posOffset }\r\n    }\r\n  }\r\n}\r\n","export const SimplexNoise2D = `\r\n  // Simplex 2D noise\r\n  //\r\n  vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\r\n\r\n  float snoise(vec2 v){\r\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\r\n            -0.577350269189626, 0.024390243902439);\r\n    vec2 i  = floor(v + dot(v, C.yy) );\r\n    vec2 x0 = v -   i + dot(i, C.xx);\r\n    vec2 i1;\r\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\r\n    vec4 x12 = x0.xyxy + C.xxzz;\r\n    x12.xy -= i1;\r\n    i = mod(i, 289.0);\r\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\r\n    + i.x + vec3(0.0, i1.x, 1.0 ));\r\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\r\n      dot(x12.zw,x12.zw)), 0.0);\r\n    m = m*m ;\r\n    m = m*m ;\r\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\r\n    vec3 h = abs(x) - 0.5;\r\n    vec3 ox = floor(x + 0.5);\r\n    vec3 a0 = x - ox;\r\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\r\n    vec3 g;\r\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\r\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\r\n    return 130.0 * dot(m, g);\r\n  }\r\n`\r\n\r\nexport const SimplexNoise3D = `\r\n  //\tSimplex 3D Noise \r\n  //\tby Ian McEwan, Ashima Arts\r\n  //\r\n  vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\r\n  vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\r\n\r\n  float snoise(vec3 v){ \r\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\r\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\r\n\r\n    // First corner\r\n    vec3 i  = floor(v + dot(v, C.yyy) );\r\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\r\n\r\n    // Other corners\r\n    vec3 g = step(x0.yzx, x0.xyz);\r\n    vec3 l = 1.0 - g;\r\n    vec3 i1 = min( g.xyz, l.zxy );\r\n    vec3 i2 = max( g.xyz, l.zxy );\r\n\r\n    //  x0 = x0 - 0. + 0.0 * C \r\n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\r\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\r\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\r\n\r\n    // Permutations\r\n    i = mod(i, 289.0 ); \r\n    vec4 p = permute( permute( permute( \r\n              i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\r\n            + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \r\n            + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\r\n\r\n    // Gradients\r\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\r\n    float n_ = 1.0/7.0; // N=7\r\n    vec3  ns = n_ * D.wyz - D.xzx;\r\n\r\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\r\n\r\n    vec4 x_ = floor(j * ns.z);\r\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\r\n\r\n    vec4 x = x_ *ns.x + ns.yyyy;\r\n    vec4 y = y_ *ns.x + ns.yyyy;\r\n    vec4 h = 1.0 - abs(x) - abs(y);\r\n\r\n    vec4 b0 = vec4( x.xy, y.xy );\r\n    vec4 b1 = vec4( x.zw, y.zw );\r\n\r\n    vec4 s0 = floor(b0)*2.0 + 1.0;\r\n    vec4 s1 = floor(b1)*2.0 + 1.0;\r\n    vec4 sh = -step(h, vec4(0.0));\r\n\r\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\r\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\r\n\r\n    vec3 p0 = vec3(a0.xy,h.x);\r\n    vec3 p1 = vec3(a0.zw,h.y);\r\n    vec3 p2 = vec3(a1.xy,h.z);\r\n    vec3 p3 = vec3(a1.zw,h.w);\r\n\r\n    //Normalise gradients\r\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\r\n    p0 *= norm.x;\r\n    p1 *= norm.y;\r\n    p2 *= norm.z;\r\n    p3 *= norm.w;\r\n\r\n    // Mix final noise value\r\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\r\n    m = m * m;\r\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \r\n                                  dot(p2,x2), dot(p3,x3) ) );\r\n  }\r\n`;\r\n","import { SimplexNoise2D, SimplexNoise3D } from './SimplexNoise'\r\n\r\nexport const PixelSwarmTargetPositionShader = `\r\n  // precision highp float;\r\n  uniform float time;\r\n  uniform float delta;\r\n  uniform int targetType;\r\n\r\n  ${SimplexNoise3D}\r\n\r\n  float odeO3(float x, float y, float z, \r\n              float a1, float a2, float a3, float a4, float a5, \r\n              float a6, float a7, float a8, float a9, float a10, \r\n              float a11, float a12, float a13, float a14, float a15, \r\n              float a16, float a17, float a18, float a19, float a20) {\r\n    return a1*0.0 + a2*x + a3*x*x + a4*x*x*x + a5*x*x*y \\\r\n          + a6*x*x*z + a7*x*y + a8*x*y*y + a9*x*y*z + a10*x*z \\\r\n          + a11*x*z*z + a12*y + a13*y*y + a14*y*y*y + a15*y*y*z \\\r\n          + a16*y*z + a17*y*z*z + a18*z + a19*z*z + a20*z*z*z;\r\n  }\r\n\r\n  #define odeO3Full(x, y, z, \\\r\n                    a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,  \\\r\n                    a11, a12, a13, a14, a15, a16, a17, a18, a19, a20,  \\\r\n                    a21, a22, a23, a24, a25, a26, a27, a28, a29, a30,  \\\r\n                    a31, a32, a33, a34, a35, a36, a37, a38, a39, a40,  \\\r\n                    a41, a42, a43, a44, a45, a46, a47, a48, a49, a50,  \\\r\n                    a51, a52, a53, a54, a55, a56, a57, a58, a59, a60) vec3( \\\r\n    odeO3(x, y, z, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,  \\\r\n          a11, a12, a13, a14, a15, a16, a17, a18, a19, a20), \\\r\n    odeO3(x, y, z, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30,  \\\r\n          a31, a32, a33, a34, a35, a36, a37, a38, a39, a40), \\\r\n    odeO3(x, y, z, a41, a42, a43, a44, a45, a46, a47, a48, a49, a50,  \\\r\n          a51, a52, a53, a54, a55, a56, a57, a58, a59, a60) \\\r\n  )\r\n\r\n  #define rescale(scale) \\\r\n    scaleFactor = scale; \\\r\n    rescaled = (target - offset) * scaleFactor; \\\r\n    float x = rescaled.x; \\\r\n    float y = rescaled.y; \\\r\n    float z = rescaled.z;\r\n\r\n  void main()\t{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n    vec3 target = texture2D(targetPositionTex, uv).xyz;\r\n    // target.x += delta * 10.0;\r\n\r\n    float speed = 5.0;\r\n    float scaleFactor = 10.0;\r\n    vec3 offset = vec3(0.0, 0.0, 0.0);\r\n    vec3 rescaled = (target - offset) * scaleFactor;\r\n    float localTime = time + gl_FragCoord.x * 10.0 + gl_FragCoord.y * 25.0;\r\n\r\n    vec3 dtdt;\r\n\r\n    // // Sprott's D=3 O=3 flows\r\n    // dtdt = odeO3Full(rescaled.x, rescaled.y, rescaled.z,\r\n    //                   0.5, 0.0, -0.6, 0.2, -0.1, 0.2, -0.6, 0.8, -0.6, -0.4, -0.2, -0.2, -1.2, 0.4, 0.8, 0.1, 1.2, 1.2, 1.0, 0.3, 0.1, 0.4, 0.2, 0.3, 0.9, -0.4, 1.1, -0.1, -1.0, 0.2, 0.1, -1.2, 1.2, -0.6, -0.3, -0.4, 0.5, 0.2, 0.3, -0.7, 0.4, -1.1, -0.7, 0.0, 0.2, 0.5, -0.8, 0.4, -0.3, 0.2, 0.2, 0.8, -1.1, 1.1, -0.9, -0.4, 0.9, 0.2, -0.1, 1.2);\r\n\r\n    if(targetType == 1) {\r\n      // Thomas' cyclically symmetric attractor\r\n      // rescale(4.0);\r\n      float b = 0.208186;\r\n      dtdt.x = sin(rescaled.y) - b * rescaled.x;\r\n      dtdt.y = sin(rescaled.z) - b * rescaled.y;\r\n      dtdt.z = sin(rescaled.x) - b * rescaled.z;\r\n    } else if(targetType == 2) {\r\n      // Sprott's simplest chaotic flow, Case A\r\n      speed = 4.0;\r\n      rescale(1.0 / 120.0);\r\n      dtdt.x = rescaled.y;\r\n      dtdt.y = -rescaled.x + rescaled.y * rescaled.z;\r\n      dtdt.z = 1.0 - rescaled.y * rescaled.y;\r\n\r\n      // speed = 4.0;\r\n      // rescale(1.0 / 80.0);\r\n      // dtdt.x = y;\r\n      // dtdt.y = y*z - x;\r\n      // dtdt.z = 1.0 - y*y;\r\n    } else if(targetType == 3) {\r\n      // van der Pol oscillator\r\n      speed = 1.0;\r\n      rescale(4.0);\r\n      float A = 0.9;\r\n      float omega = 0.5;\r\n      float v = rescaled.y;\r\n      float dv = A * sin(omega * localTime) - (x*x - 1.0) * v - x;\r\n      dtdt.x = v;\r\n      dtdt.y = dv;\r\n    } else if(targetType == 4) {\r\n      // Custom - excog\r\n\r\n      // float maxInteractionDist = 0.01;\r\n      // for(float i=0.0; i<resolution.x; i++) {\r\n      //   for(float j=0.0; j<resolution.y; j++) {\r\n      //     vec3 otherTarget = texture2D(targetPositionTex, vec2(i, j) / resolution.xy).xyz;\r\n      //     if(abs(otherTarget.x - target.x) > maxInteractionDist\r\n      //       || abs(otherTarget.y - target.y) > maxInteractionDist)\r\n      //       continue;\r\n      //     dtdt.x -= otherTarget.x - target.x;\r\n      //     dtdt.y -= otherTarget.y - target.y;\r\n      //   }\r\n      // }\r\n\r\n      speed = 8.0;\r\n      rescale(5.0);\r\n      float rPhase = pow(abs(sin(time * 0.2 + gl_FragCoord.y / resolution.y * 0.2)), 2.0);\r\n      float r = 5.0 * rPhase + 0.1;\r\n      // gl_FragCoord.x / resolution.x * 2.0 * 3.14159\r\n      float a = atan(y, x) + 0.5 * pow(1.0 - rPhase, 2.0) * time * (gl_FragCoord.x / resolution.x + 0.01);\r\n\r\n      float noiseScale = 2.0;\r\n      vec3 noiseSource = vec3(x, y, z) * 1.0 + time * 0.2;\r\n      // vec3 noiseSource = vec3(1.0, 1.0, 1.0) * 1.0 + time * 0.2;\r\n      vec3 noiseV = vec3(\r\n        snoise(noiseSource + vec3(527.234, 65.34, 982.873)),\r\n        snoise(noiseSource + vec3(42.45, 22.644, 863.386)),\r\n        0\r\n      );\r\n      noiseV = vec3(\r\n        snoise(noiseSource + 0.5 * noiseV + vec3(35.642, 64.266, 3.656)),\r\n        snoise(noiseSource + 0.5 * noiseV + vec3(763.135, 7.2367, 62.8465)),\r\n        0\r\n      );\r\n      r += noiseV.x * 1.1;\r\n      // noiseV *= noiseScale;\r\n      noiseV *= 0.0;\r\n\r\n      dtdt.x += r * cos(a) - x + noiseV.x;\r\n      dtdt.y += r * sin(a) - y + noiseV.y;\r\n    }\r\n\r\n    vec3 newTarget = (rescaled + dtdt * delta * speed) / scaleFactor + offset;\r\n    \r\n    // Prevent pixel loss from chaotic blowups\r\n    if(abs(newTarget.x) > 10000.0 || abs(newTarget.y) > 10000.0 || abs(newTarget.z) > 10000.0)\r\n      newTarget = vec3(0.0, 0.0, 0.0);\r\n\r\n    gl_FragColor = vec4(newTarget, 1.0);\r\n}\r\n`;\r\n\r\nexport const PixelSwarmVelocityShader = `\r\n  // precision highp float;\r\n  uniform float time;\r\n  uniform float delta;\r\n  uniform vec2 targetScale;\r\n  uniform float velocityNoiseScale;\r\n  // uniform vec2 targetPositionOffset;\r\n  uniform vec2 dTargetOffset;\r\n\r\n  ${SimplexNoise3D}\r\n\r\n  void main()\t{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n    vec3 pos = texture2D(positionTex, uv).xyz;\r\n    pos.xy -= dTargetOffset;\r\n    vec3 target = texture2D(targetPositionTex, uv).xyz;\r\n    target.xy *= targetScale;\r\n    // target.xy += targetPositionOffset - dTargetOffset;\r\n    vec3 v = texture2D(velocityTex, uv).xyz;\r\n\r\n    vec3 goTargetV = 2.0 * (target-pos);\r\n\r\n    float noiseScale = 20.0 * (1.0 + 2.0 * pow(length(goTargetV), 0.5));\r\n    vec3 noiseSource = vec3(1.0, 1.0, 1.0) + pos * 1.0 + time * 1.0;\r\n    // noiseSource.x += uv.x * 1475.754;\r\n    // noiseSource.y += uv.y * 286.46247;\r\n    vec3 noiseV = vec3(\r\n      snoise(noiseSource + vec3(43.521, 65.254, 982.143)),\r\n      snoise(noiseSource + vec3(654.45, 22.644, 863.345)),\r\n      0\r\n    );\r\n    noiseV = vec3(\r\n      snoise(noiseSource + 0.5 * noiseV + vec3(35.642, 64.266, 3.656)),\r\n      snoise(noiseSource + 0.5 * noiseV + vec3(763.135, 7.2367, 62.8465)),\r\n      0\r\n    );\r\n    noiseV *= noiseScale * velocityNoiseScale;\r\n    // noiseV *= 0.0;\r\n    // vec3 noiseV = vec3(0.0, 0.0, 0.0);\r\n\r\n    float decay = 0.8;\r\n    // vec3 noiseSource = vec3(uv.x, uv.y, 0) * 1000.0 + time * 1.0;\r\n    vec3 newV = decay * v + (1.0-decay) * (goTargetV + noiseV);\r\n    // newV.z = 0.0;\r\n\r\n    gl_FragColor = vec4(newV, 1.0);\r\n}\r\n`;\r\n\r\nexport const PixelSwarmPositionShader = `\r\n  // precision highp float;\r\n  uniform float delta;\r\n  uniform vec2 dTargetOffset;\r\n\r\n  void main()\t{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n    vec3 pos = texture2D(positionTex, uv).xyz;\r\n    pos.xy -= dTargetOffset;\r\n    vec3 v = texture2D(velocityTex, uv).xyz;\r\n\r\n    // const float minDelta = 0.5;\r\n    // vec3 dpos = v * min(2.0 * delta, 1.0) + (target-pos) * min(0.5 * delta, 1.0);\r\n    // if(pos.x != target.x && abs(dpos.x) < minDelta)\r\n    //   dpos.x = clamp(target.x - pos.x, -minDelta, minDelta);\r\n    // if(pos.y != target.y && abs(dpos.y) < minDelta)\r\n    //   dpos.y = clamp(target.y - pos.y, -minDelta, minDelta);\r\n\r\n    gl_FragColor = vec4(pos + v * min(delta, 1.0), 1.0);\r\n}\r\n`;\r\n\r\n// export const PixelSwarmPositionShader = `\r\n//   precision highp float;\r\n//   uniform float delta;\r\n//   uniform sampler2D targetPositionTex;\r\n\r\n//   vec4 pack2HalfToRGBA(vec2 v) {\r\n//     vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\r\n//     return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\r\n//   }\r\n\r\n//   vec2 unpack2HalfToRGBA(vec4 v) {\r\n//     return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\r\n//   }\r\n\r\n//   void main()\t{\r\n//     vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n\r\n//     highpvec2 pos = unpack2HalfToRGBA(texture2D(positionTex, uv));\r\n//     vec2 target = unpack2HalfToRGBA(texture2D(targetPositionTex, uv));\r\n\r\n//     gl_FragColor = pack2HalfToRGBA(pos + (target-pos) * min(2.0 * delta, 1.0));\r\n\r\n//     // vec3 pos = texture2D(positionTex, uv).xyz;\r\n//     // vec3 target = texture2D(targetPositionTex, uv).xyz;\r\n\r\n//     // gl_FragColor = vec4(pos + (target-pos) * min(0.5 * delta, 1.0), 1.0);\r\n// }\r\n// `;\r\n\r\nexport const PixelSwarmColorShader = `\r\n  // precision highp float;\r\n  uniform float delta;\r\n  uniform sampler2D targetColorTex;\r\n\r\n  void main()\t{\r\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\r\n    vec4 color = texture2D(colorTex, uv);\r\n    vec4 target = texture2D(targetColorTex, uv);\r\n\r\n    const float minDelta = 0.1;\r\n    vec4 dcolor = (target-color) * min(0.5 * delta, 1.0);\r\n    // if(color.w != target.w && abs(dcolor.w) < minDelta)\r\n    //   dcolor.w = clamp(target.w - color.w, -minDelta, minDelta);\r\n\r\n    gl_FragColor = color + dcolor;\r\n}\r\n`;\r\n","import * as THREE from 'three';\r\nimport React, { useEffect, useState, useMemo, useRef } from 'react';\r\nimport { useFrame, useThree } from 'react-three-fiber';\r\nimport { a } from 'react-spring/three';\r\n\r\nimport { dpi } from '../config'\r\nimport { store, updateSwarmState } from '../core/state'\r\nimport GPUComputationRenderer from '../compute/GPUComputationRenderer';\r\nimport PixelSwarmShader from '../shaders/PixelSwarmShader';\r\nimport { PixelSwarmTargetPositionShader, PixelSwarmVelocityShader, PixelSwarmPositionShader, PixelSwarmColorShader} from '../shaders/PixelSwarmComputeShaders';\r\n\r\nexport default function PixelSwarm({ children, position }) {\r\n  const computeTexSize = 128;\r\n  const n = computeTexSize * computeTexSize;\r\n  \r\n  const {\r\n    gl,\r\n    size: { width, height },\r\n  } = useThree();\r\n\r\n  const [ target, setTarget ] = useState(null);\r\n  const [ targets, setTargets ] = useState(store.getState().swarmTargets);\r\n  const updateTargets = () => {\r\n    setTargets(store.getState().swarmTargets);\r\n  };\r\n  store.subscribe(() => {\r\n    updateTargets();\r\n  })\r\n\r\n  // const ascii2coeff = new Map([...\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"].map((c, i) => [c, (-1.2 + i * 0.1).toFixed(1)]));\r\n  // console.log('coeffs', [...\"RMGOLOGUGIKKAQUNYYWPNQOPVIXLCONAYGJIROPFQBFMOREQJOOUBXDIVOLY\"].map(c => ascii2coeff.get(c)).join(', '));\r\n\r\n  // gl.precision = \"mediump\";\r\n\r\n  // const { gl } = useThree();\r\n  \r\n  // Setup point attribute buffers\r\n  const positions = useMemo(\r\n    () => {\r\n      var arr = [];\r\n      for(let i = 0; i < n * 3; i+=3) {\r\n        arr.push(\r\n          Math.random() * width,\r\n          Math.random() * -height,\r\n          0\r\n        );\r\n      }\r\n      return new Float32Array(arr);\r\n    },\r\n    [n]\r\n  );\r\n  const references = useMemo(\r\n    () => {\r\n      var arr = [];\r\n      for(let i = 0; i < n * 2; i+=2)\r\n        arr.push(\r\n          (i / 2) % computeTexSize / computeTexSize, \r\n          Math.floor(i / 2 / computeTexSize) / computeTexSize,\r\n          // (i / 2 + 1) % computeTexSize / computeTexSize, \r\n          // Math.floor((i / 2 + 1) / computeTexSize) / computeTexSize\r\n        );\r\n      return new Float32Array(arr);\r\n    },\r\n    [n]\r\n  );\r\n\r\n  // const pack2HalfToRGBA = (v) => {\r\n  //   let r = [ v[0], ( v[0] * 255.0 ) % 1, v[1], ( v[1] * 255.0 ) % 1];\r\n  //   return [ r[0] - r[1] / 255.0, r[1], r[2] - r[3] / 255.0, r[3]];\r\n  // }\r\n\r\n  // Compute texture intialization\r\n  const fillPositionTex = (tex) => {\r\n    let texData = tex.image.data;\r\n    for(var i=0; i<texData.length; i+=4) {\r\n      texData[i] = positions[i / 4 * 3];\r\n      texData[i + 1] = positions[i / 4 * 3 + 1];\r\n      texData[i + 2] = positions[i / 4 * 3 + 2];\r\n    }\r\n    // for(var i=0; i<texData.length; i+=8) {\r\n    //   let xy = pack2HalfToRGBA([positions[i / 8 * 3], positions[i / 8 * 3 + 1]]);\r\n    //   let zz = pack2HalfToRGBA([positions[i / 8 * 3 + 2], positions[i / 8 * 3 + 2]]);\r\n    //   texData[i] = xy[0];\r\n    //   texData[i + 1] = xy[1];\r\n    //   texData[i + 2] = xy[2];\r\n    //   texData[i + 3] = xy[3];\r\n    //   texData[i + 4] = zz[0];\r\n    //   texData[i + 5] = zz[1];\r\n    // }\r\n  }\r\n  const fillZeroTex = (tex) => {\r\n    let texData = tex.image.data;\r\n    for(var i=0; i<texData.length; i+=4) {\r\n      texData[i] = 0.0;\r\n      texData[i + 1] = 0.0;\r\n      texData[i + 2] = 0.0;\r\n      texData[i + 3] = 1.0;\r\n    }\r\n  }\r\n\r\n  // Setup compute shaders\r\n  const [ gpuCompute, targetPositionVariable, positionVariable, targetPositionTex, velocityVariable, colorVariable, targetColorTex ] = useMemo(\r\n    () => {\r\n      let gpuCompute = new GPUComputationRenderer(computeTexSize, computeTexSize, gl);\r\n      var positionTex = gpuCompute.createTexture();\r\n      var targetPositionTex = gpuCompute.createTexture();\r\n      var velocityTex = gpuCompute.createTexture();\r\n      fillPositionTex(positionTex);\r\n      fillPositionTex(targetPositionTex);\r\n      fillZeroTex(velocityTex);\r\n      var colorTex = gpuCompute.createTexture();\r\n      var targetColorTex = gpuCompute.createTexture();\r\n      fillZeroTex(colorTex);\r\n      fillZeroTex(targetColorTex);\r\n\r\n      let targetPositionVariable = gpuCompute.addVariable(\"targetPositionTex\", PixelSwarmTargetPositionShader, targetPositionTex);\r\n      targetPositionVariable.material.uniforms[\"time\"] = { value: 0 };\r\n      targetPositionVariable.material.uniforms[\"delta\"] = { value: 0 };\r\n      targetPositionVariable.material.uniforms[\"targetType\"] = { value: 0 };\r\n      targetPositionVariable.material.uniforms[\"targetPositionTex\"] = { value: targetPositionTex };\r\n\r\n      let velocityVariable = gpuCompute.addVariable(\"velocityTex\", PixelSwarmVelocityShader, velocityTex);\r\n      velocityVariable.material.uniforms[\"time\"] = { value: 0 };\r\n      velocityVariable.material.uniforms[\"delta\"] = { value: 0 };\r\n      velocityVariable.material.uniforms[\"targetPositionTex\"] = { value: targetPositionTex };\r\n      velocityVariable.material.uniforms[\"targetScale\"] = { value: [0, 0] };\r\n      velocityVariable.material.uniforms[\"targetPositionOffset\"] = { value: [0, 0] };\r\n      velocityVariable.material.uniforms[\"dTargetOffset\"] = { value: [0, 0] };\r\n      velocityVariable.material.uniforms[\"velocityNoiseScale\"] = { value: 0 };\r\n\r\n      let positionVariable = gpuCompute.addVariable(\"positionTex\", PixelSwarmPositionShader, positionTex);\r\n      positionVariable.material.uniforms[\"delta\"] = { value: 0 };\r\n      positionVariable.material.uniforms[\"dTargetOffset\"] = { value: [0, 0] };\r\n      \r\n      gpuCompute.setVariableDependencies(targetPositionVariable, [ targetPositionVariable ]);\r\n      gpuCompute.setVariableDependencies(velocityVariable, [ positionVariable, velocityVariable, targetPositionVariable ]);\r\n      gpuCompute.setVariableDependencies(positionVariable, [ positionVariable, velocityVariable ]);\r\n\r\n      let colorVariable = gpuCompute.addVariable(\"colorTex\", PixelSwarmColorShader, colorTex);\r\n      colorVariable.material.uniforms[\"targetColorTex\"] = { value: targetColorTex };\r\n      colorVariable.material.uniforms[\"delta\"] = { value: 0 };\r\n      gpuCompute.setVariableDependencies(colorVariable, [ colorVariable ]);\r\n\r\n      var error = gpuCompute.init();\r\n      if ( error !== null ) {\r\n          console.error( error );\r\n      }\r\n      store.dispatch(updateSwarmState({ positionTex }));\r\n      return [ gpuCompute, targetPositionVariable, positionVariable, targetPositionTex, velocityVariable, colorVariable, targetColorTex ];\r\n    },\r\n    []\r\n  );\r\n\r\n  // Update compute buffers with new target data\r\n  useEffect(\r\n    () => {\r\n      if(!target)\r\n        return;\r\n      if(target.type === \"content\" && target.positions.length > 0) {\r\n        let texData = targetPositionTex.image.data;\r\n        for(let i=0; i<texData.length; i+=4) {\r\n          texData[i] = target.positions[(i / 4 * 3) % target.positions.length];\r\n          texData[i + 1] = target.positions[(i / 4 * 3 + 1) % target.positions.length];\r\n          texData[i + 2] = target.positions[(i / 4 * 3 + 2) % target.positions.length];\r\n        }\r\n  \r\n        // for(var i=0; i<texData.length; i+=8) {\r\n        //   let xy = pack2HalfToRGBA([target.positions[i / 8 * 3], target.positions[i / 8 * 3 + 1]]);\r\n        //   let zz = pack2HalfToRGBA([target.positions[i / 8 * 3 + 2], target.positions[i / 8 * 3 + 2]]);\r\n        //   texData[i] = xy[0];\r\n        //   texData[i + 1] = xy[1];\r\n        //   texData[i + 2] = xy[2];\r\n        //   texData[i + 3] = xy[3];\r\n        //   texData[i + 4] = zz[0];\r\n        //   texData[i + 5] = zz[1];\r\n        // }\r\n        targetPositionTex.needsUpdate = true;\r\n        texData = targetColorTex.image.data;\r\n        for(let i=0; i<texData.length; i+=4) {\r\n          texData[i] = target.colors[i];\r\n          texData[i + 1] = Math.random() < 0.95 ? target.colors[i + 1] : 0.0;\r\n          texData[i + 2] = target.colors[i + 2];\r\n          texData[i + 3] = target.colors[i + 3];\r\n        }\r\n        targetColorTex.needsUpdate = true;\r\n      } else {\r\n        let texData = targetPositionTex.image.data;\r\n        for(let i=0; i<texData.length; i+=4) {\r\n          texData[i] = (Math.random() - 0.5);\r\n          texData[i + 1] = (Math.random() - 0.5);\r\n          texData[i + 2] = 0.0;\r\n        }\r\n\r\n        texData = targetColorTex.image.data;\r\n        for(let i=0; i<texData.length; i+=4) {\r\n          texData[i] = 0;\r\n          texData[i + 1] = 0;\r\n          texData[i + 2] = 0;\r\n          texData[i + 3] = 0.4 + 0.6 * Math.random();\r\n        }\r\n        targetColorTex.needsUpdate = true;\r\n      }\r\n  \r\n      gpuCompute.renderTexture(targetPositionTex, gpuCompute.getCurrentRenderTarget(targetPositionVariable));\r\n    }, [target]\r\n  );\r\n\r\n  const [swarmShader] = useMemo(() => {\r\n    const loader = new THREE.TextureLoader();\r\n    const swarmShader = new PixelSwarmShader({\r\n      pointTexture: loader.load('/textures/box-shadow-16px.png'),\r\n      posOffset: [0, 0],\r\n      time: 0,\r\n      targetType: 0,\r\n    });\r\n    return [swarmShader]\r\n  }, []);\r\n\r\n  const [ lastTime, lastTargetOffset ] = useMemo(\r\n    () => {\r\n      return [ \r\n        { value: performance.now() },\r\n        { value: [ 0, 0 ] },\r\n       ]\r\n    }, []\r\n  );\r\n  useFrame(() => {\r\n    let curTime = performance.now();\r\n    let dtime = Math.min((curTime - lastTime.value) / 1000, 0.1);\r\n    lastTime.value = performance.now();\r\n    // console.log('dtime', dtime * 1000.0);\r\n    // setLastTime(curTime);\r\n\r\n    // Update time-related variables\r\n    targetPositionVariable.material.uniforms[\"time\"].value = curTime / 1000.0;\r\n    targetPositionVariable.material.uniforms[\"delta\"].value = dtime;\r\n    velocityVariable.material.uniforms[\"time\"].value = curTime / 1000.0;\r\n    velocityVariable.material.uniforms[\"delta\"].value = dtime;\r\n    positionVariable.material.uniforms[\"delta\"].value = dtime;\r\n    colorVariable.material.uniforms[\"delta\"].value = dtime;\r\n    swarmShader.uniforms.time.value = curTime / 1000.0;\r\n\r\n    // Find the most appropriate `SwarmTarget`\r\n    let intendedTarget;\r\n    let scrollTop = document.scrollingElement.scrollTop;\r\n    // Ref: https://stackoverflow.com/a/8876069\r\n    var viewport = [\r\n      Math.max(document.documentElement.clientWidth, window.innerWidth || 0),\r\n      Math.max(document.documentElement.clientHeight, window.innerHeight || 0)\r\n    ];\r\n    let maxPriority = 0;\r\n    let targetIds = Object.keys(targets);\r\n    for(let i=0; i<targetIds.length; i++) {\r\n      let el = document.getElementById(targets[targetIds[i]].id);\r\n      // Is target inside the viewport?\r\n      if(el.offsetTop + el.offsetHeight > scrollTop && el.offsetTop < scrollTop + viewport[1]) {\r\n        let visibleHeight = Math.min(scrollTop + viewport[1], el.offsetTop + el.offsetHeight)\r\n                          - Math.max(scrollTop, el.offsetTop);\r\n        let priority = visibleHeight;\r\n        // Still has a part below the viewport's edge?\r\n        if(el.offsetTop + el.offsetHeight > scrollTop + viewport[1])\r\n          priority *= 2.0;\r\n        if(priority > maxPriority) {\r\n          maxPriority = priority;\r\n          intendedTarget = targets[targetIds[i]];\r\n        }\r\n      }\r\n    }\r\n    if(intendedTarget && intendedTarget !== target) {\r\n      setTarget(intendedTarget);\r\n    }\r\n\r\n    // Update target's size and position in compute shader\r\n    if(target) {\r\n      let targetEl = document.getElementById(target.id);\r\n      let targetSize = [\r\n        targetEl.offsetWidth,\r\n        targetEl.offsetHeight\r\n      ];\r\n      let targetOffset = [\r\n        targetEl.offsetLeft + targetSize[0] / 2, \r\n        -targetEl.offsetTop - targetSize[1] / 2\r\n      ];\r\n\r\n      // Keep compute values near [0,0] to preserve the precision on mobile\r\n      let dTargetOffset = [ \r\n        targetOffset[0] - lastTargetOffset.value[0],\r\n        targetOffset[1] - lastTargetOffset.value[1]\r\n      ];\r\n      velocityVariable.material.uniforms[\"dTargetOffset\"].value = dTargetOffset;\r\n      velocityVariable.material.uniforms[\"targetScale\"].value = targetSize;\r\n      positionVariable.material.uniforms[\"dTargetOffset\"].value = dTargetOffset;\r\n      lastTargetOffset.value = targetOffset;\r\n\r\n      // Which type of dynamics should the shader compute?\r\n      let targetType = 0;\r\n      let velocityNoiseScale = 1.0;\r\n      switch(target.type) {\r\n        case \"content\":\r\n          targetType = 0;\r\n          break;\r\n        case \"generative-thomas\":\r\n          targetType = 1;\r\n          break;\r\n        case \"generative-sprott\":\r\n          targetType = 2;\r\n          break;\r\n        case \"generative-van-der-pol\":\r\n          targetType = 3;\r\n          break;\r\n        case \"generative-excog\":\r\n          targetType = 4;\r\n          velocityNoiseScale = 0.0;\r\n          break;\r\n        default:\r\n          targetType = 0;\r\n      }\r\n      targetPositionVariable.material.uniforms[\"targetType\"].value = targetType;\r\n      velocityVariable.material.uniforms[\"velocityNoiseScale\"].value = velocityNoiseScale;\r\n\r\n      swarmShader.uniforms.targetType.value = targetType;\r\n      swarmShader.uniforms.pointScale.value = target.scale / 2 * dpi;\r\n      swarmShader.uniforms.posOffset.value = targetOffset;\r\n    } else {\r\n      velocityVariable.material.uniforms[\"dTargetOffset\"].value = [ 0, 0 ];\r\n      positionVariable.material.uniforms[\"dTargetOffset\"].value = [ 0, 0 ];\r\n    }\r\n    // let t1 = Date.now();\r\n    // let time = Date.now() * 0.0005;\r\n    // let pos = posAttr.current.array;\r\n    // let alpha = alphaAttr.current.array;\r\n    // posAttr.current.needsUpdate = true;\r\n    // alphaAttr.current.needsUpdate = true;\r\n\r\n    gpuCompute.compute();\r\n    swarmShader.uniforms.positionTex.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;\r\n    swarmShader.uniforms.colorTex.value = gpuCompute.getCurrentRenderTarget(colorVariable).texture;\r\n    // console.log('itertime', performance.now() - curTime);\r\n  });\r\n  return (\r\n    <>\r\n      <a.points position={position} frustumCulled={false}>\r\n        <bufferGeometry attach=\"geometry\">\r\n          <bufferAttribute\r\n            attachObject={['attributes', 'position']}\r\n            count={positions.length / 3}\r\n            array={positions}\r\n            itemSize={3}\r\n          />\r\n          <bufferAttribute\r\n            attachObject={['attributes', 'reference']}\r\n            count={references.length / 2}\r\n            array={references}\r\n            itemSize={2}\r\n          />\r\n        </bufferGeometry>\r\n        <shaderMaterial\r\n          attach=\"material\"\r\n          args={[swarmShader]}\r\n        />\r\n      </a.points>\r\n    </>\r\n  );\r\n};\r\n","export function shuffle(a, stride=1, repeatIndices=null, repeatStride=1) {\r\n  let ii = 0;\r\n  let indices = [];\r\n  for (let i = a.length - stride; i > 0; i -= stride) {\r\n    const j = repeatIndices ? repeatIndices[ii++] / repeatStride * stride : Math.floor(Math.random() * (i / stride + 1)) * stride;\r\n    indices.push(j);\r\n    for(let k=0; k<stride; k++)\r\n      [a[i+k], a[j+k]] = [a[j+k], a[i+k]];\r\n  }\r\n  return indices;\r\n}\r\n","import React, { useEffect, useRef, useState } from 'react';\r\nimport { connect } from 'react-redux';\r\n\r\nimport { dpi } from '../config'\r\nimport { updateSwarmTarget, removeSwarmTarget } from '../core/state'\r\nimport { shuffle } from '../util/array';\r\nimport HTMLRenderer from '../util/HTMLRenderer';\r\n\r\nfunction SwarmTarget({ children, id, size, image, targetData, updateSwarmTarget, removeSwarmTarget, type=\"content\", scale=4 }) {\r\n  // const [ size, setSize ] = useState([window.innerWidth, window.innerHeight]);\r\n\r\n  // useEffect(() => {\r\n  //   const onResize = () => { setSize([window.innerWidth, window.innerHeight]); console.log('onResize', window.innerHeight); };\r\n  //   // window.addEventListener('orientationchange', onResize);\r\n  //   window.addEventListener('resize', onResize);\r\n  //   return () => {\r\n  //     // window.removeEventListener('orientationchange', onResize);\r\n  //     window.removeEventListener('resize', onResize);\r\n  //   }\r\n  // }, [])\r\n\r\n  const el = useRef();\r\n  useEffect(\r\n    () => {\r\n      async function renderContent() {\r\n        let positions = [];\r\n        let colors = [];\r\n        \r\n        let newTargetData = targetData;\r\n        if(!newTargetData) {\r\n          newTargetData = {\r\n            id: id,\r\n          };\r\n        }\r\n        newTargetData.type = type;\r\n        newTargetData.scale = scale;\r\n        if(type === \"content\" && !('positions' in newTargetData)) {\r\n          // let canvas = await HTMLRenderer.render(children);\r\n          // console.log('canvas.width', canvas.width)\r\n          // let img = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);\r\n          let img = await HTMLRenderer.renderImage(image, size);\r\n          for(let i = 0; i < img.length / 4; i++) {\r\n            let pix = [img[i*4], img[i*4+1], img[i*4+2], img[i*4+3]];\r\n            if(pix[3] > 0.0) {\r\n              positions.push(\r\n                ((i % (size[0] * dpi)) / dpi + 0.25) / size[0] - 0.5, \r\n                (-Math.floor(i / (size[0] * dpi)) / dpi + 0.25) / size[1] + 0.5, \r\n                0\r\n              );\r\n              colors.push(\r\n                pix[0] / 255.0,\r\n                pix[1] / 255.0,\r\n                pix[2] / 255.0,\r\n                pix[3] / 255.0 * (0.4 + 0.6 * Math.random())\r\n                // Math.min(1.0 - (pix[0] + pix[1] + pix[2]) / 3 / 255.0 , pix[3] / 255.0) * (0.4 + 0.6 * Math.random())\r\n              );\r\n            }\r\n          }\r\n          let shuffleIndices = shuffle(positions, 3);\r\n          shuffle(colors, 4, shuffleIndices, 3);\r\n          \r\n          // console.log('newShape.length', newShape.length)\r\n          // while(newShape.length < positions.length)\r\n          //   newShape.push(0, 0, 0);\r\n          // while(newAlphas.length < alphas.length)\r\n          //   newAlphas.push(0);\r\n\r\n          newTargetData.positions = positions;\r\n          newTargetData.colors = colors;\r\n        }\r\n      \r\n        // if(newShape.length > 0)\r\n          updateSwarmTarget(id, newTargetData);\r\n        // else\r\n        //   setTimeout(renderContent, 500);\r\n      };\r\n      // // Wait for Three.js to intialize, otherwise the rendering can fail\r\n      // let waitForGL = setInterval(() => {\r\n      //   if(document.getElementById(\"gl-canvas\")) {\r\n      //     setTimeout(renderContent, 100);\r\n      //     // renderContent();\r\n      //     clearInterval(waitForGL);\r\n      //   }\r\n      // }, 100);\r\n      renderContent();\r\n\r\n      return () => {\r\n        removeSwarmTarget(id);\r\n      }\r\n    }, [el, type, scale]\r\n  );\r\n\r\n  return (\r\n    <div id={id} className=\"swarm-target\" ref={el}>\r\n      <div style={{width: size[0]+'px', height: size[1]+'px'}}></div>\r\n      {/* {children} */}\r\n    </div>\r\n  );\r\n}\r\n\r\nconst mapStateToProps = (state, ownProps) => {\r\n  if(ownProps.id in state.swarmTargets) {\r\n    return {\r\n      targetData: state.swarmTargets[ownProps.id]\r\n    };\r\n  }\r\n  return {};\r\n};\r\n\r\nconst mapDispatchToProps = dispatch => {\r\n  return {\r\n    updateSwarmTarget: (target, payload) => {\r\n      dispatch(updateSwarmTarget(target, payload));\r\n    },\r\n    removeSwarmTarget: (target) => {\r\n      dispatch(removeSwarmTarget(target));\r\n    }\r\n  };\r\n};\r\n\r\nexport default connect(\r\n  mapStateToProps,\r\n  mapDispatchToProps\r\n)(SwarmTarget);\r\n","import React from 'react'\r\nimport SwarmTarget from './SwarmTarget'\r\n\r\nexport default function ProjectInfo({ project }) {\r\n  return (\r\n    <div id={project.id} className=\"project\" key={project.id}>\r\n      <div className=\"container\">\r\n        <div className={\"project-name \" + project.id}>{project.name}</div>\r\n        <div className=\"project-desc\">{project.desc}</div>\r\n        {project.tech && <div className=\"project-tech\">\r\n          <span className=\"tech-list\">\r\n            {project.tech.map((tech, i) =>\r\n              <div key={i} className=\"item\">{tech}</div>\r\n            )}\r\n          </span>\r\n        </div>}\r\n        {project.links && <div className=\"project-links\">\r\n          {project.links.map((link, i) => \r\n            <a key={i} href={link.url} target=\"_blank\" rel=\"noopener noreferrer\">\r\n              {link.label}\r\n            </a>\r\n          )}\r\n        </div>}\r\n      </div>\r\n      <div className=\"container project-preview-media\">\r\n        {project.image && \r\n          <>\r\n            <img src={project.image} alt={project.name + \" preview\"} />\r\n            <div className=\"shadow\" />\r\n          </>\r\n        }\r\n        {project.video && \r\n          <>\r\n            <video autoPlay playsInline loop muted src={project.video} />\r\n            <div className=\"shadow\" />\r\n          </>\r\n        }\r\n        {/* <SwarmTarget \r\n          id={\"project-symbol-\" + project.id} \r\n          type={project.previewType} \r\n          size={project.previewSize} \r\n          scale={project.previewScale ? project.previewScale : 4} \r\n          image={project.image}\r\n        /> */}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n","import * as THREE from 'three'\r\n\r\nexport default class DynamicCanvasShader extends THREE.ShaderMaterial {\r\n  constructor(options) {\r\n    super({\r\n      vertexShader: `\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n          vUv = uv; \r\n          vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\r\n          gl_Position = projectionMatrix * modelViewPosition;\r\n        }\r\n      `,\r\n      fragmentShader: `\r\n        uniform sampler2D texture;\r\n        varying vec2 vUv;\r\n\r\n        void main() {\r\n          gl_FragColor = texture2D(texture, vUv);\r\n          // gl_FragColor.w = min(gl_FragColor.w, 0.999);\r\n        }\r\n      `,\r\n      blendSrc: THREE.SrcAlphaFactor,\r\n      blendDst: THREE.OneMinusSrcColorFactor,\r\n      blending: THREE.CustomBlending,\r\n      // blendEquation: THREE.AddEquation,\r\n      // blending: THREE.AdditiveBlending,\r\n      // blending: THREE.SubtractiveBlending,\r\n      // blending: THREE.NormalBlending,\r\n      // depthTest: false,\r\n      transparent: true,\r\n      // vertexColors: true,\r\n    });\r\n\r\n    this.uniforms = {\r\n      texture: { value: options.texture },\r\n    }\r\n  }\r\n}\r\n","import { WebGLMultisampleRenderTarget as MSRT, WebGLRenderTarget, RGBFormat, RGBAFormat, UnsignedByteType, OrthographicCamera, Scene, Mesh, Color } from 'three'\r\nimport * as THREE from 'three';\r\nimport React, { useEffect, useState, useMemo, useRef } from 'react';\r\nimport { useFrame, useThree, extend } from 'react-three-fiber';\r\nimport { a } from 'react-spring/three';\r\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer'\r\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass'\r\nimport { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass'\r\nimport { CopyShader } from 'three/examples/jsm/shaders/CopyShader'\r\n\r\nimport { dpi } from '../config'\r\nimport { store, updateSwarmState } from '../core/state'\r\nimport GPUComputationRenderer from '../compute/GPUComputationRenderer';\r\nimport PixelSwarmShader from '../shaders/PixelSwarmShader';\r\nimport { PixelSwarmTargetPositionShader, PixelSwarmVelocityShader, PixelSwarmPositionShader, PixelSwarmColorShader} from '../shaders/PixelSwarmComputeShaders';\r\nimport SceneController from '../components/SceneController'\r\nimport PixelSwarm from '../components/PixelSwarm'\r\nimport DynamicCanvasShader from '../shaders/DynamicCanvasShader';\r\n\r\n// extend({ EffectComposer, ShaderPass, RenderPass })\r\n\r\nexport default function DynamicCanvas({ children }) {\r\n  // const computeTexSize = 128;\r\n  // const n = computeTexSize * computeTexSize;\r\n  \r\n  // const {\r\n  //   gl,\r\n  //   size: { width, height },\r\n  // } = useThree();\r\n\r\n  // const [ swarmState, setSwarmState ] = useState(store.getState().swarmState);\r\n  // const updateSwarmState = () => {\r\n  //   setSwarmState(store.getState().swarmState);\r\n  // };\r\n  // store.subscribe(() => {\r\n  //   updateSwarmState();\r\n  // })\r\n\r\n  // const fillZeroTex = (tex) => {\r\n  //   let texData = tex.image.data;\r\n  //   for(var i=0; i<texData.length; i+=4) {\r\n  //     texData[i] = 0.0;\r\n  //     texData[i + 1] = 0.0;\r\n  //     texData[i + 2] = 0.0;\r\n  //     texData[i + 3] = 0.0;\r\n  //   }\r\n  // }\r\n\r\n  // // Setup compute shaders\r\n  // const [ gpuCompute, targetPositionVariable, positionVariable, targetPositionTex, velocityVariable, colorVariable, targetColorTex ] = useMemo(\r\n  //   () => {\r\n  //     let gpuCompute = new GPUComputationRenderer(computeTexSize, computeTexSize, gl);\r\n  //     var positionTex = gpuCompute.createTexture();\r\n  //     var targetPositionTex = gpuCompute.createTexture();\r\n  //     var velocityTex = gpuCompute.createTexture();\r\n  //     fillPositionTex(positionTex);\r\n  //     fillPositionTex(targetPositionTex);\r\n  //     fillZeroTex(velocityTex);\r\n  //     var colorTex = gpuCompute.createTexture();\r\n  //     var targetColorTex = gpuCompute.createTexture();\r\n  //     fillZeroTex(colorTex);\r\n  //     fillZeroTex(targetColorTex);\r\n\r\n  //     let targetPositionVariable = gpuCompute.addVariable(\"targetPositionTex\", PixelSwarmTargetPositionShader, targetPositionTex);\r\n  //     targetPositionVariable.material.uniforms[\"time\"] = { value: 0 };\r\n  //     targetPositionVariable.material.uniforms[\"delta\"] = { value: 0 };\r\n  //     targetPositionVariable.material.uniforms[\"targetType\"] = { value: 0 };\r\n  //     targetPositionVariable.material.uniforms[\"targetPositionTex\"] = { value: targetPositionTex };\r\n\r\n  //     let velocityVariable = gpuCompute.addVariable(\"velocityTex\", PixelSwarmVelocityShader, velocityTex);\r\n  //     velocityVariable.material.uniforms[\"time\"] = { value: 0 };\r\n  //     velocityVariable.material.uniforms[\"delta\"] = { value: 0 };\r\n  //     velocityVariable.material.uniforms[\"targetPositionTex\"] = { value: targetPositionTex };\r\n  //     velocityVariable.material.uniforms[\"targetScale\"] = { value: [0, 0] };\r\n  //     velocityVariable.material.uniforms[\"targetPositionOffset\"] = { value: [0, 0] };\r\n  //     velocityVariable.material.uniforms[\"dTargetOffset\"] = { value: [0, 0] };\r\n  //     velocityVariable.material.uniforms[\"velocityNoiseScale\"] = { value: 0 };\r\n\r\n  //     let positionVariable = gpuCompute.addVariable(\"positionTex\", PixelSwarmPositionShader, positionTex);\r\n  //     positionVariable.material.uniforms[\"delta\"] = { value: 0 };\r\n  //     positionVariable.material.uniforms[\"dTargetOffset\"] = { value: [0, 0] };\r\n      \r\n  //     gpuCompute.setVariableDependencies(targetPositionVariable, [ targetPositionVariable ]);\r\n  //     gpuCompute.setVariableDependencies(velocityVariable, [ positionVariable, velocityVariable, targetPositionVariable ]);\r\n  //     gpuCompute.setVariableDependencies(positionVariable, [ positionVariable, velocityVariable ]);\r\n\r\n  //     let colorVariable = gpuCompute.addVariable(\"colorTex\", PixelSwarmColorShader, colorTex);\r\n  //     colorVariable.material.uniforms[\"targetColorTex\"] = { value: targetColorTex };\r\n  //     colorVariable.material.uniforms[\"delta\"] = { value: 0 };\r\n  //     gpuCompute.setVariableDependencies(colorVariable, [ colorVariable ]);\r\n\r\n  //     var error = gpuCompute.init();\r\n  //     if ( error !== null ) {\r\n  //         console.error( error );\r\n  //     }\r\n  //     return [ gpuCompute, targetPositionVariable, positionVariable, targetPositionTex, velocityVariable, colorVariable, targetColorTex ];\r\n  //   },\r\n  //   []\r\n  // );\r\n\r\n  // // Update compute buffers with new target data\r\n  // useEffect(\r\n  //   () => {\r\n  //     if(!target)\r\n  //       return;\r\n\r\n  //       texData = targetColorTex.image.data;\r\n  //       for(let i=0; i<texData.length; i+=4) {\r\n  //         texData[i] = 0;\r\n  //         texData[i + 1] = 0;\r\n  //         texData[i + 2] = 0;\r\n  //         texData[i + 3] = 0.4 + 0.6 * Math.random();\r\n  //       }\r\n  //       targetColorTex.needsUpdate = true;\r\n      \r\n  \r\n  //     gpuCompute.renderTexture(targetPositionTex, gpuCompute.getCurrentRenderTarget(targetPositionVariable));\r\n  //   }, [target]\r\n  // );\r\n\r\n  // const [swarmShader] = useMemo(() => {\r\n  //   const loader = new THREE.TextureLoader();\r\n  //   const swarmShader = new PixelSwarmShader({\r\n  //     pointTexture: loader.load('/textures/box-shadow-16px.png'),\r\n  //     posOffset: [0, 0],\r\n  //     time: 0,\r\n  //     targetType: 0,\r\n  //   });\r\n  //   return [swarmShader]\r\n  // }, []);\r\n\r\n  // const [ lastTime, lastTargetOffset ] = useMemo(\r\n  //   () => {\r\n  //     return [ \r\n  //       { value: performance.now() },\r\n  //       { value: [ 0, 0 ] },\r\n  //      ]\r\n  //   }, []\r\n  // );\r\n  // useFrame(() => {\r\n  //   let curTime = performance.now();\r\n  //   let dtime = Math.min((curTime - lastTime.value) / 1000, 0.1);\r\n  //   lastTime.value = performance.now();\r\n  //   // console.log('dtime', dtime * 1000.0);\r\n  //   // setLastTime(curTime);\r\n\r\n  //   // Update time-related variables\r\n  //   targetPositionVariable.material.uniforms[\"time\"].value = curTime / 1000.0;\r\n  //   targetPositionVariable.material.uniforms[\"delta\"].value = dtime;\r\n  //   velocityVariable.material.uniforms[\"time\"].value = curTime / 1000.0;\r\n  //   velocityVariable.material.uniforms[\"delta\"].value = dtime;\r\n  //   positionVariable.material.uniforms[\"delta\"].value = dtime;\r\n  //   colorVariable.material.uniforms[\"delta\"].value = dtime;\r\n  //   swarmShader.uniforms.time.value = curTime / 1000.0;\r\n\r\n  //   // Find the most appropriate `SwarmTarget`\r\n  //   let intendedTarget;\r\n  //   let scrollTop = document.scrollingElement.scrollTop;\r\n  //   // Ref: https://stackoverflow.com/a/8876069\r\n  //   var viewport = [\r\n  //     Math.max(document.documentElement.clientWidth, window.innerWidth || 0),\r\n  //     Math.max(document.documentElement.clientHeight, window.innerHeight || 0)\r\n  //   ];\r\n  //   let maxPriority = 0;\r\n  //   let targetIds = Object.keys(targets);\r\n  //   for(let i=0; i<targetIds.length; i++) {\r\n  //     let el = document.getElementById(targets[targetIds[i]].id);\r\n  //     // Is target inside the viewport?\r\n  //     if(el.offsetTop + el.offsetHeight > scrollTop && el.offsetTop < scrollTop + viewport[1]) {\r\n  //       let visibleHeight = Math.min(scrollTop + viewport[1], el.offsetTop + el.offsetHeight)\r\n  //                         - Math.max(scrollTop, el.offsetTop);\r\n  //       let priority = visibleHeight;\r\n  //       // Still has a part below the viewport's edge?\r\n  //       if(el.offsetTop + el.offsetHeight > scrollTop + viewport[1])\r\n  //         priority *= 2.0;\r\n  //       if(priority > maxPriority) {\r\n  //         maxPriority = priority;\r\n  //         intendedTarget = targets[targetIds[i]];\r\n  //       }\r\n  //     }\r\n  //   }\r\n  //   if(intendedTarget && intendedTarget !== target) {\r\n  //     setTarget(intendedTarget);\r\n  //   }\r\n\r\n  //   // Update target's size and position in compute shader\r\n  //   if(target) {\r\n  //     let targetEl = document.getElementById(target.id);\r\n  //     let targetSize = [\r\n  //       targetEl.offsetWidth,\r\n  //       targetEl.offsetHeight\r\n  //     ];\r\n  //     let targetOffset = [\r\n  //       targetEl.offsetLeft + targetSize[0] / 2, \r\n  //       -targetEl.offsetTop - targetSize[1] / 2\r\n  //     ];\r\n\r\n  //     // Keep compute values near [0,0] to preserve the precision on mobile\r\n  //     let dTargetOffset = [ \r\n  //       targetOffset[0] - lastTargetOffset.value[0],\r\n  //       targetOffset[1] - lastTargetOffset.value[1]\r\n  //     ];\r\n  //     velocityVariable.material.uniforms[\"dTargetOffset\"].value = dTargetOffset;\r\n  //     velocityVariable.material.uniforms[\"targetScale\"].value = targetSize;\r\n  //     positionVariable.material.uniforms[\"dTargetOffset\"].value = dTargetOffset;\r\n  //     lastTargetOffset.value = targetOffset;\r\n\r\n  //     targetPositionVariable.material.uniforms[\"targetType\"].value = targetType;\r\n  //     velocityVariable.material.uniforms[\"velocityNoiseScale\"].value = velocityNoiseScale;\r\n\r\n  //     swarmShader.uniforms.targetType.value = targetType;\r\n  //     swarmShader.uniforms.pointScale.value = target.scale / 2 * dpi;\r\n  //     swarmShader.uniforms.posOffset.value = targetOffset;\r\n  //   } else {\r\n  //     velocityVariable.material.uniforms[\"dTargetOffset\"].value = [ 0, 0 ];\r\n  //     positionVariable.material.uniforms[\"dTargetOffset\"].value = [ 0, 0 ];\r\n  //   }\r\n  //   // let t1 = Date.now();\r\n  //   // let time = Date.now() * 0.0005;\r\n  //   // let pos = posAttr.current.array;\r\n  //   // let alpha = alphaAttr.current.array;\r\n  //   // posAttr.current.needsUpdate = true;\r\n  //   // alphaAttr.current.needsUpdate = true;\r\n\r\n  //   gpuCompute.compute();\r\n  //   swarmShader.uniforms.positionTex.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;\r\n  //   swarmShader.uniforms.colorTex.value = gpuCompute.getCurrentRenderTarget(colorVariable).texture;\r\n  //   // console.log('itertime', performance.now() - curTime);\r\n  // });\r\n\r\n\r\n  const rttScene = useRef();\r\n  const rttGroup = useRef();\r\n  const rttBg = useRef();\r\n  const realScene = useRef();\r\n  const realBg = useRef();\r\n  const { gl, scene, camera, size } = useThree()\r\n  const devicePixelRatio = dpi;\r\n  const { width, height } = { width: size.width * devicePixelRatio, height: size.height * devicePixelRatio }\r\n  const composer = useRef()\r\n  const [ renderTargets, rttCamera ] = useMemo(() => {\r\n    const targetOptions = {\r\n      format: RGBAFormat,\r\n      type: UnsignedByteType,\r\n      magFilter: THREE.NearestFilter,\r\n      minFilter: THREE.NearestFilter,\r\n      depthBuffer: false,\r\n      stencilBuffer: false,\r\n      generateMipmaps: false,\r\n    };\r\n    const target1 = new WebGLRenderTarget(width, height, targetOptions);\r\n    const target2 = new WebGLRenderTarget(width, height, targetOptions);\r\n    // target.samples = 8\r\n    const rttCamera = new OrthographicCamera( camera.left, camera.right, camera.top, camera.bottom, camera.near, camera.far );\r\n    return [ [ target1, target2 ], rttCamera ]\r\n  }, [width, height])\r\n  // useEffect(() => void composer.current.setSize(width, height), [width, height])\r\n  useFrame(() => {\r\n    rttCamera.position.x = camera.position.x;\r\n    rttCamera.position.y = camera.position.y;\r\n    rttCamera.position.z = camera.position.z;\r\n    // rttGroup.current.position.x = Math.sin(Date.now() / 1000) * 100;\r\n\r\n    // gl.autoClear = false;\r\n    rttBg.current.material.map = renderTargets[0].texture;\r\n    // canvasShader.uniforms.texture.value = renderTargets[0].texture;\r\n    gl.setClearColor(new Color('#000'), 0.0);\r\n    gl.setRenderTarget( renderTargets[1] );\r\n    gl.clear();\r\n    gl.render( rttScene.current, rttCamera );\r\n    [ renderTargets[0], renderTargets[1] ] = [ renderTargets[1], renderTargets[0] ];\r\n    realBg.current.material.map = renderTargets[0].texture;\r\n\r\n    // gl.setClearColor(new Color('#fff'), 1.0);\r\n    gl.setRenderTarget( null );\r\n    gl.clear();\r\n    gl.render( realScene.current, camera );\r\n  }, 1)  // \r\n\r\n  // console.log('renderTarget', renderTarget)\r\n\r\n  const [canvasShader] = useMemo(() => {\r\n    const canvasShader = new DynamicCanvasShader({\r\n      //\r\n    });\r\n    return [canvasShader]\r\n  }, []);\r\n\r\n  return (\r\n    <>\r\n      {/* <effectComposer ref={composer} args={[gl, renderTarget]} renderToScreen={false}>\r\n        <renderPass attachArray=\"passes\" args={[scene, camera]} />\r\n        <shaderPass attachArray=\"passes\" args={CopyShader} />\r\n      </effectComposer> */}\r\n      <scene ref={rttScene}>\r\n        <SceneController>\r\n          {/* <mesh frustumCulled={false} position={[width / dpi / 2, -height / dpi / 2, -100]}>\r\n            <planeBufferGeometry attach=\"geometry\" args={[width / dpi, height / dpi]} />\r\n            <meshStandardMaterial attach=\"material\" color=\"#fff\" opacity={1.0} />\r\n          </mesh> */}\r\n          <mesh ref={rttBg} frustumCulled={false} position={[width / dpi / 2, -height / dpi / 2, -100]}>\r\n            <planeBufferGeometry attach=\"geometry\" args={[width / dpi, height / dpi]} />\r\n            <meshBasicMaterial attach=\"material\" transparent opacity={0.9 /*0.97*/} />\r\n            {/* <shaderMaterial attach=\"material\" args={[canvasShader]} /> */}\r\n          </mesh>\r\n          <group ref={rttGroup}>\r\n            {children}\r\n          </group>\r\n          {/* <mesh \r\n            position={new THREE.Vector3(0, -200, 0)}\r\n            rotation={new THREE.Euler(0, 0, 0)} \r\n            castShadow \r\n            receiveShadow>\r\n            <boxGeometry attach=\"geometry\" args={[200, 200, 200]} />\r\n            <meshStandardMaterial attach=\"material\" />\r\n          </mesh> */}\r\n          {/* <RenderText opacity={1} position={new THREE.Vector3(0, 10, 0)} color=\"black\">\r\n            Hello, dear traveller\r\n          </RenderText> */}\r\n        </SceneController>\r\n        {/* <mesh frustumCulled={false} position={[600, -600, 100]}>\r\n          <planeBufferGeometry attach=\"geometry\" args={[400, 400]} />\r\n          <meshStandardMaterial attach=\"material\" color=\"#000\" />\r\n        </mesh> */}\r\n      </scene>\r\n      \r\n      <scene ref={realScene}>\r\n        <SceneController>\r\n          <mesh ref={realBg} frustumCulled={false} position={[width / dpi / 2, -height / dpi / 2, -0]}>\r\n            <planeBufferGeometry attach=\"geometry\" args={[width / dpi, height / dpi]} />\r\n            <meshStandardMaterial attach=\"material\" opacity={1.0} />\r\n          </mesh>\r\n          {/* <mesh frustumCulled={false} position={[width / dpi / 2, -height / dpi / 2, -100]}>\r\n            <planeBufferGeometry attach=\"geometry\" args={[width / dpi, height / dpi]} />\r\n            <meshStandardMaterial attach=\"material\" color=\"#fff\" opacity={1.0} />\r\n          </mesh> */}\r\n          {/* <PixelSwarm position={[0, 0, 0]} /> */}\r\n          {/* <PixelSwarm position={[0, 0, 0]} /> */}\r\n          {/* <mesh frustumCulled={false} position={[600, -600, 100]}>\r\n            <planeBufferGeometry attach=\"geometry\" args={[400, 400]} />\r\n            <meshStandardMaterial attach=\"material\" color=\"#000\" />\r\n          </mesh> */}\r\n          {/* <PixelSwarm position={[0, 0, 0]} /> */}\r\n          {/* <mesh \r\n            position={new THREE.Vector3(0, -200, 0)}\r\n            rotation={new THREE.Euler(0, 0, 0)} \r\n            castShadow \r\n            receiveShadow>\r\n            <boxGeometry attach=\"geometry\" args={[200, 200, 200]} />\r\n            <meshStandardMaterial attach=\"material\" />\r\n          </mesh> */}\r\n          {/* <RenderText opacity={1} position={new THREE.Vector3(0, 10, 0)} color=\"black\">\r\n            Hello, dear traveller\r\n          </RenderText> */}\r\n        </SceneController>\r\n        {/* <mesh frustumCulled={false} position={[600, -600, 100]}>\r\n          <planeBufferGeometry attach=\"geometry\" args={[400, 400]} />\r\n          <meshStandardMaterial attach=\"material\" color=\"#000\" />\r\n        </mesh> */}\r\n      </scene>\r\n    </>\r\n  );\r\n};\r\n","import * as THREE from 'three'\nimport ReactDOM from 'react-dom'\nimport React, { useEffect, useState, useMemo, useRef } from 'react'\nimport { Canvas } from 'react-three-fiber'\nimport FontAwesome from 'react-fontawesome'\nimport './App.scss';\n\nimport { dpi } from './config'\nimport { store } from './core/state'\nimport { sleep } from './util/time'\nimport { ProjectData } from './data/ProjectData'\nimport SceneController from './components/SceneController'\nimport RenderText from './components/RenderText'\nimport ProjectPreview from './components/ProjectPreview'\nimport PixelSwarm from './components/PixelSwarm'\nimport SwarmTarget from './components/SwarmTarget'\nimport ProjectInfo from './components/ProjectInfo'\nimport DynamicCanvas from './components/DynamicCanvas'\n\n// const gpu = new GPU({mode: \"gpu\"});\n\nfunction App() {\n  const [ locked, setLocked ] = useState(true);\n\n  const [ logoShape, setLogoShape ] = useState(\"content\");\n  const [ logoPointSize, setLogoPointSize ] = useState(2);\n  const [ revealStage, setRevealStage ] = useState(0);\n  useEffect(\n    () => {\n      const reveal = async() => {\n        if(window.location.hash.length < 1) {\n          await sleep(4000);\n          setRevealStage(1);\n          await sleep(2000);\n          setRevealStage(2);\n          await sleep(1500);\n          setLogoShape(\"generative-excog\");\n          setLogoPointSize(2);\n          await sleep(1000);\n        } else {\n          setRevealStage(2);\n          setLogoPointSize(2);\n          setLogoShape(\"generative-excog\");\n        }\n        setLocked(false);\n      };\n      reveal();\n\n      // // document.documentElement.className = \"locked\";\n      // setTimeout(() => {\n      //   // document.documentElement.className = \"\";\n      //   setLocked(false);\n      // }, 1000);\n    }, []\n  );\n\n  const [ shouldRender, setShouldRender ] = useState(true);\n\n  useEffect(() => {\n    const onScroll = e => {\n      if(e.target.documentElement.scrollTop > window.innerHeight) {\n        if(shouldRender) {\n          console.log('shouldRender false', shouldRender, false)\n          setShouldRender(false);\n        }\n      } else {\n        if(!shouldRender) {\n          console.log('shouldRender true', shouldRender, true)\n          setShouldRender(true);\n        }\n      }\n    };\n    window.addEventListener(\"scroll\", onScroll);\n\n    return () => window.removeEventListener(\"scroll\", onScroll);\n  }, [shouldRender]);\n\n  return (\n    <div className=\"App\">\n      <div className=\"main-canvas\">\n        <Canvas\n          id=\"gl-canvas\"\n          camera={{\n            fov: 75,\n            near: 1.0,\n            far: 10000,\n            position: [0, 0, 1000],\n            rotation: new THREE.Euler(0, 0, 0),\n            // zoom: 2.5,\n          }}\n          orthographic={true}\n          pixelRatio={dpi}\n          invalidateFrameloop={!shouldRender}\n          // onCreated={({ gl }) => { gl.shadowMap.enabled = true; gl.shadowMap.type = THREE.PCFSoftShadowMap; }}\n          // gl2={true}\n        >\n          <DynamicCanvas>\n            {/* <mesh frustumCulled={false} position={[300, -300, 0]}>\n              <planeBufferGeometry attach=\"geometry\" args={[400, 400]} />\n              <meshStandardMaterial attach=\"material\" color=\"#000\" />\n            </mesh> */}\n            <PixelSwarm position={[0, 0, 0]} />\n          </DynamicCanvas>\n\n          {/* <SceneController>\n            <PixelSwarm position={[0, 0, 0]} />\n          </SceneController> */}\n          \n          {/* <mesh frustumCulled={false} position={[300, -300, 100]}>\n            <planeBufferGeometry attach=\"geometry\" args={[400, 400]} />\n            <meshStandardMaterial attach=\"material\" color=\"#000\" />\n          </mesh> */}\n        </Canvas>\n      </div>\n      <div className=\"content\">\n        {/* <div style={{ height: '525vh' }} /> */}\n        <div className=\"hero\">\n          <div className=\"welcome\">\n            <SwarmTarget id=\"logo\" type={logoShape} size={[ 200, 200 ]} scale={logoPointSize} image=\"/textures/logo.png\"/>\n            {/* <SwarmTarget id=\"logo\" type=\"generative-thomas\" size={[ 400, 400 ]} scale={4} /> */}\n            <div className={\"welcome-line\" + (revealStage < 1 ? \" hidden\" : \"\")}>\n              Hello, dear traveller\n            </div>\n            <div className={\"welcome-line\" + (revealStage < 2 ? \" hidden\" : \"\")}>\n              i'm GoS, and here's stuff i love and do\n            </div>\n          </div>\n          <div className={\"proceed\" + (locked ? \" hidden\" : \"\")}>\n            <FontAwesome name=\"caret-down\" />\n          </div>\n        </div>\n        <div className={\"delayed-content\" + (locked ? \" locked\" : \"\")}>\n          {/* <div className=\"container\"> */}\n            {ProjectData.inProgress.map((project, i) => \n              <ProjectInfo key={i} project={project} />\n            )}\n            <div className=\"container\">\n              <div className=\"project-group-header\">\n                Archive\n              </div>\n            </div>\n            {ProjectData.archive.map((project, i) => \n              <ProjectInfo key={i} project={project} />\n            )}\n            {/* <SwarmTarget id=\"epilogue\" type=\"generative-thomas\" size={[ 400, 400 ]} scale={4} /> */}\n            <div className=\"container\">\n              <div className=\"footer\">\n                <a href=\"https://twitter.com/just_gos\" target=\"_blank\" rel=\"noopener noreferrer\">\n                  <FontAwesome name=\"twitter\" />\n                </a>\n              </div>\n            </div>\n          </div>\n        {/* </div> */}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { Provider } from 'react-redux'\nimport { store } from './core/state'\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>, \n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}